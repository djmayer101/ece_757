<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>gem5: cpu/simple/atomic.cc Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
<div class="header">
  <div class="headertitle">
<h1>cpu/simple/atomic.cc</h1>  </div>
</div>
<div class="contents">
<a href="atomic_8cc.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment"> * Copyright (c) 2012 ARM Limited</span>
<a name="l00003"></a>00003 <span class="comment"> * All rights reserved.</span>
<a name="l00004"></a>00004 <span class="comment"> *</span>
<a name="l00005"></a>00005 <span class="comment"> * The license below extends only to copyright in the software and shall</span>
<a name="l00006"></a>00006 <span class="comment"> * not be construed as granting a license to any other intellectual</span>
<a name="l00007"></a>00007 <span class="comment"> * property including but not limited to intellectual property relating</span>
<a name="l00008"></a>00008 <span class="comment"> * to a hardware implementation of the functionality of the software</span>
<a name="l00009"></a>00009 <span class="comment"> * licensed hereunder.  You may use the software subject to the license</span>
<a name="l00010"></a>00010 <span class="comment"> * terms below provided that you ensure that this notice is replicated</span>
<a name="l00011"></a>00011 <span class="comment"> * unmodified and in its entirety in all distributions of the software,</span>
<a name="l00012"></a>00012 <span class="comment"> * modified or unmodified, in source code or in binary form.</span>
<a name="l00013"></a>00013 <span class="comment"> *</span>
<a name="l00014"></a>00014 <span class="comment"> * Copyright (c) 2002-2005 The Regents of The University of Michigan</span>
<a name="l00015"></a>00015 <span class="comment"> * All rights reserved.</span>
<a name="l00016"></a>00016 <span class="comment"> *</span>
<a name="l00017"></a>00017 <span class="comment"> * Redistribution and use in source and binary forms, with or without</span>
<a name="l00018"></a>00018 <span class="comment"> * modification, are permitted provided that the following conditions are</span>
<a name="l00019"></a>00019 <span class="comment"> * met: redistributions of source code must retain the above copyright</span>
<a name="l00020"></a>00020 <span class="comment"> * notice, this list of conditions and the following disclaimer;</span>
<a name="l00021"></a>00021 <span class="comment"> * redistributions in binary form must reproduce the above copyright</span>
<a name="l00022"></a>00022 <span class="comment"> * notice, this list of conditions and the following disclaimer in the</span>
<a name="l00023"></a>00023 <span class="comment"> * documentation and/or other materials provided with the distribution;</span>
<a name="l00024"></a>00024 <span class="comment"> * neither the name of the copyright holders nor the names of its</span>
<a name="l00025"></a>00025 <span class="comment"> * contributors may be used to endorse or promote products derived from</span>
<a name="l00026"></a>00026 <span class="comment"> * this software without specific prior written permission.</span>
<a name="l00027"></a>00027 <span class="comment"> *</span>
<a name="l00028"></a>00028 <span class="comment"> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS</span>
<a name="l00029"></a>00029 <span class="comment"> * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT</span>
<a name="l00030"></a>00030 <span class="comment"> * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR</span>
<a name="l00031"></a>00031 <span class="comment"> * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT</span>
<a name="l00032"></a>00032 <span class="comment"> * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,</span>
<a name="l00033"></a>00033 <span class="comment"> * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT</span>
<a name="l00034"></a>00034 <span class="comment"> * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,</span>
<a name="l00035"></a>00035 <span class="comment"> * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</span>
<a name="l00036"></a>00036 <span class="comment"> * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</span>
<a name="l00037"></a>00037 <span class="comment"> * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE</span>
<a name="l00038"></a>00038 <span class="comment"> * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<a name="l00039"></a>00039 <span class="comment"> *</span>
<a name="l00040"></a>00040 <span class="comment"> * Authors: Steve Reinhardt</span>
<a name="l00041"></a>00041 <span class="comment"> */</span>
<a name="l00042"></a>00042 
<a name="l00043"></a>00043 <span class="preprocessor">#include &quot;arch/locked_mem.hh&quot;</span>
<a name="l00044"></a>00044 <span class="preprocessor">#include &quot;arch/mmapped_ipr.hh&quot;</span>
<a name="l00045"></a>00045 <span class="preprocessor">#include &quot;arch/utility.hh&quot;</span>
<a name="l00046"></a>00046 <span class="preprocessor">#include &quot;<a class="code" href="bigint_8hh.html">base/bigint.hh</a>&quot;</span>
<a name="l00047"></a>00047 <span class="preprocessor">#include &quot;config/the_isa.hh&quot;</span>
<a name="l00048"></a>00048 <span class="preprocessor">#include &quot;<a class="code" href="atomic_8hh.html">cpu/simple/atomic.hh</a>&quot;</span>
<a name="l00049"></a>00049 <span class="preprocessor">#include &quot;<a class="code" href="exetrace_8hh.html">cpu/exetrace.hh</a>&quot;</span>
<a name="l00050"></a>00050 <span class="preprocessor">#include &quot;debug/Drain.hh&quot;</span>
<a name="l00051"></a>00051 <span class="preprocessor">#include &quot;debug/ExecFaulting.hh&quot;</span>
<a name="l00052"></a>00052 <span class="preprocessor">#include &quot;debug/SimpleCPU.hh&quot;</span>
<a name="l00053"></a>00053 <span class="preprocessor">#include &quot;<a class="code" href="packet_8hh.html" title="Declaration of the Packet class.">mem/packet.hh</a>&quot;</span>
<a name="l00054"></a>00054 <span class="preprocessor">#include &quot;<a class="code" href="packet__access_8hh.html">mem/packet_access.hh</a>&quot;</span>
<a name="l00055"></a>00055 <span class="preprocessor">#include &quot;<a class="code" href="physical_8hh.html">mem/physical.hh</a>&quot;</span>
<a name="l00056"></a>00056 <span class="preprocessor">#include &quot;params/AtomicSimpleCPU.hh&quot;</span>
<a name="l00057"></a>00057 <span class="preprocessor">#include &quot;<a class="code" href="sim_2faults_8hh.html">sim/faults.hh</a>&quot;</span>
<a name="l00058"></a>00058 <span class="preprocessor">#include &quot;<a class="code" href="sim_2system_8hh.html">sim/system.hh</a>&quot;</span>
<a name="l00059"></a>00059 <span class="preprocessor">#include &quot;<a class="code" href="full__system_8hh.html">sim/full_system.hh</a>&quot;</span>
<a name="l00060"></a>00060 
<a name="l00061"></a>00061 <span class="keyword">using namespace </span>std;
<a name="l00062"></a>00062 <span class="keyword">using namespace </span>TheISA;
<a name="l00063"></a>00063 
<a name="l00064"></a><a class="code" href="structAtomicSimpleCPU_1_1TickEvent.html#acdcc67ea6da57a326551a395d1b6e1d2">00064</a> <a class="code" href="structAtomicSimpleCPU_1_1TickEvent.html#acdcc67ea6da57a326551a395d1b6e1d2">AtomicSimpleCPU::TickEvent::TickEvent</a>(<a class="code" href="classAtomicSimpleCPU.html">AtomicSimpleCPU</a> *<a class="code" href="namespaceArmISA.html#a21f7b327cbedf079597394ec2c3f2a6d">c</a>)
<a name="l00065"></a>00065     : <a class="code" href="classEvent.html">Event</a>(CPU_Tick_Pri), cpu(c)
<a name="l00066"></a>00066 {
<a name="l00067"></a>00067 }
<a name="l00068"></a>00068 
<a name="l00069"></a>00069 
<a name="l00070"></a>00070 <span class="keywordtype">void</span>
<a name="l00071"></a><a class="code" href="structAtomicSimpleCPU_1_1TickEvent.html#a825a450249ed2b9140a4e22b155c08ba">00071</a> <a class="code" href="structAtomicSimpleCPU_1_1TickEvent.html#a825a450249ed2b9140a4e22b155c08ba">AtomicSimpleCPU::TickEvent::process</a>()
<a name="l00072"></a>00072 {
<a name="l00073"></a>00073     <a class="code" href="structAtomicSimpleCPU_1_1TickEvent.html#a80e17fe73186806bcd1e6e9e0964f17c">cpu</a>-&gt;<a class="code" href="classAtomicSimpleCPU.html#a3b5859c96b689d7c6e8d3df2d0bb1de5">tick</a>();
<a name="l00074"></a>00074 }
<a name="l00075"></a>00075 
<a name="l00076"></a>00076 <span class="keyword">const</span> <span class="keywordtype">char</span> *
<a name="l00077"></a><a class="code" href="structAtomicSimpleCPU_1_1TickEvent.html#aa4b73099f504687bc973fd1cc3eb2c6c">00077</a> <a class="code" href="structAtomicSimpleCPU_1_1TickEvent.html#aa4b73099f504687bc973fd1cc3eb2c6c" title="Return a C string describing the event.">AtomicSimpleCPU::TickEvent::description</a>()<span class="keyword"> const</span>
<a name="l00078"></a>00078 <span class="keyword"></span>{
<a name="l00079"></a>00079     <span class="keywordflow">return</span> <span class="stringliteral">&quot;AtomicSimpleCPU tick&quot;</span>;
<a name="l00080"></a>00080 }
<a name="l00081"></a>00081 
<a name="l00082"></a>00082 <span class="keywordtype">void</span>
<a name="l00083"></a><a class="code" href="classAtomicSimpleCPU.html#af1da6be8b3f4a28784a719f233656f7f">00083</a> <a class="code" href="classAtomicSimpleCPU.html#af1da6be8b3f4a28784a719f233656f7f" title="init() is called after all C++ SimObjects have been created and all ports are connected.">AtomicSimpleCPU::init</a>()
<a name="l00084"></a>00084 {
<a name="l00085"></a>00085     <a class="code" href="classAtomicSimpleCPU.html#af1da6be8b3f4a28784a719f233656f7f" title="init() is called after all C++ SimObjects have been created and all ports are connected.">BaseCPU::init</a>();
<a name="l00086"></a>00086 
<a name="l00087"></a>00087     <span class="comment">// Initialise the ThreadContext&#39;s memory proxies</span>
<a name="l00088"></a>00088     <a class="code" href="classBaseSimpleCPU.html#a0ce3a38aea510a5763eee01734c41649">tcBase</a>()-&gt;<a class="code" href="classThreadContext.html#a844977d4855f84e45560b8873247783a" title="Initialise the physical and virtual port proxies and tie them to the data port of the CPU...">initMemProxies</a>(<a class="code" href="classBaseSimpleCPU.html#a0ce3a38aea510a5763eee01734c41649">tcBase</a>());
<a name="l00089"></a>00089 
<a name="l00090"></a>00090     <span class="keywordflow">if</span> (<a class="code" href="full__system_8hh.html#af929576af6f85c8849704b66d04b8370" title="The FullSystem variable can be used to determine the current mode of simulation.">FullSystem</a> &amp;&amp; !<a class="code" href="classBaseCPU.html#a8e895dfbcaacea5e84e7e5dbfcead414">params</a>()-&gt;switched_out) {
<a name="l00091"></a>00091         <a class="code" href="base_2types_8hh.html#ab39b1a4f9dad884694c7a74ed69e6a6b" title="Thread index/ID type.">ThreadID</a> size = <a class="code" href="classBaseCPU.html#a22178d56f16f4d27c17453771f334a88">threadContexts</a>.size();
<a name="l00092"></a>00092         <span class="keywordflow">for</span> (<a class="code" href="base_2types_8hh.html#ab39b1a4f9dad884694c7a74ed69e6a6b" title="Thread index/ID type.">ThreadID</a> <a class="code" href="namespaceArmISA.html#a07402644ed55c19e1a116116c548c2ac">i</a> = 0; <a class="code" href="namespaceArmISA.html#a07402644ed55c19e1a116116c548c2ac">i</a> &lt; size; ++<a class="code" href="namespaceArmISA.html#a07402644ed55c19e1a116116c548c2ac">i</a>) {
<a name="l00093"></a>00093             <a class="code" href="classThreadContext.html" title="ThreadContext is the external interface to all thread state for anything outside of the CPU...">ThreadContext</a> *<a class="code" href="classBaseSimpleCPU.html#a1d94ea1eaa23dd214f48d3833601941d" title="ThreadContext object, provides an interface for external objects to modify this thread&amp;#39;s state...">tc</a> = <a class="code" href="classBaseCPU.html#a22178d56f16f4d27c17453771f334a88">threadContexts</a>[<a class="code" href="namespaceArmISA.html#a07402644ed55c19e1a116116c548c2ac">i</a>];
<a name="l00094"></a>00094             <span class="comment">// initialize CPU, including PC</span>
<a name="l00095"></a>00095             <a class="code" href="namespaceAlphaISA.html#a06411429ba06d7939a3aedc9099788eb">TheISA::initCPU</a>(tc, tc-&gt;<a class="code" href="classThreadContext.html#a516a77735ff104335e299bf628b87614">contextId</a>());
<a name="l00096"></a>00096         }
<a name="l00097"></a>00097     }
<a name="l00098"></a>00098 
<a name="l00099"></a>00099     <span class="comment">// Atomic doesn&#39;t do MT right now, so contextId == threadId</span>
<a name="l00100"></a>00100     <a class="code" href="classAtomicSimpleCPU.html#ab1d4eecb4d4fad5a281b799a23dd315b">ifetch_req</a>.<a class="code" href="classRequest.html#a0b067551ee420e924c5e2402539df311" title="Set up CPU and thread numbers.">setThreadContext</a>(<a class="code" href="classBaseCPU.html#a512f6e0d7684ff19880a2ff9b6eeeddb">_cpuId</a>, 0); <span class="comment">// Add thread ID if we add MT</span>
<a name="l00101"></a>00101     <a class="code" href="classAtomicSimpleCPU.html#a34d4f70c5792b45e2a6210ef9de99d8b">data_read_req</a>.<a class="code" href="classRequest.html#a0b067551ee420e924c5e2402539df311" title="Set up CPU and thread numbers.">setThreadContext</a>(<a class="code" href="classBaseCPU.html#a512f6e0d7684ff19880a2ff9b6eeeddb">_cpuId</a>, 0); <span class="comment">// Add thread ID here too</span>
<a name="l00102"></a>00102     <a class="code" href="classAtomicSimpleCPU.html#ad536354f472689d58359e5182c6091a5">data_write_req</a>.<a class="code" href="classRequest.html#a0b067551ee420e924c5e2402539df311" title="Set up CPU and thread numbers.">setThreadContext</a>(<a class="code" href="classBaseCPU.html#a512f6e0d7684ff19880a2ff9b6eeeddb">_cpuId</a>, 0); <span class="comment">// Add thread ID here too</span>
<a name="l00103"></a>00103 }
<a name="l00104"></a>00104 
<a name="l00105"></a><a class="code" href="classAtomicSimpleCPU.html#a7316bea4bcc46803a8665d2b60c56cc3">00105</a> <a class="code" href="classAtomicSimpleCPU.html#a7316bea4bcc46803a8665d2b60c56cc3">AtomicSimpleCPU::AtomicSimpleCPU</a>(AtomicSimpleCPUParams *<a class="code" href="namespaceMipsISA.html#ae12ae9e12fab22594609e2fefce7f7c2">p</a>)
<a name="l00106"></a>00106     : <a class="code" href="classBaseSimpleCPU.html">BaseSimpleCPU</a>(p), tickEvent(this), width(p-&gt;width), locked(false),
<a name="l00107"></a>00107       simulate_data_stalls(p-&gt;simulate_data_stalls),
<a name="l00108"></a>00108       simulate_inst_stalls(p-&gt;simulate_inst_stalls),
<a name="l00109"></a>00109       drain_manager(NULL),
<a name="l00110"></a>00110       icachePort(<a class="code" href="trace_8hh.html#a166fa10b86d8faa127fb7c78191e3e60">name</a>() + <span class="stringliteral">&quot;.icache_port&quot;</span>, this),
<a name="l00111"></a>00111       dcachePort(<a class="code" href="trace_8hh.html#a166fa10b86d8faa127fb7c78191e3e60">name</a>() + <span class="stringliteral">&quot;.dcache_port&quot;</span>, this),
<a name="l00112"></a>00112       fastmem(p-&gt;fastmem)
<a name="l00113"></a>00113 {
<a name="l00114"></a>00114     <a class="code" href="classBaseSimpleCPU.html#a10a9927ef33b83d6cd4dbb90f2862181">_status</a> = Idle;
<a name="l00115"></a>00115 }
<a name="l00116"></a>00116 
<a name="l00117"></a>00117 
<a name="l00118"></a><a class="code" href="classAtomicSimpleCPU.html#a3c8640f6983eb388f32f8f0fe8535845">00118</a> <a class="code" href="classAtomicSimpleCPU.html#a3c8640f6983eb388f32f8f0fe8535845">AtomicSimpleCPU::~AtomicSimpleCPU</a>()
<a name="l00119"></a>00119 {
<a name="l00120"></a>00120     <span class="keywordflow">if</span> (<a class="code" href="classAtomicSimpleCPU.html#a77b35d6b2a4345c6d3971fc64a4d9342">tickEvent</a>.<a class="code" href="classEvent.html#a36bdc2ee73215ed7670a7bfc0f25ab8b" title="Determine if the current event is scheduled.">scheduled</a>()) {
<a name="l00121"></a>00121         <a class="code" href="classEventManager.html#a92b58a82b7a2bb4935f41bc4d46897b6">deschedule</a>(<a class="code" href="classAtomicSimpleCPU.html#a77b35d6b2a4345c6d3971fc64a4d9342">tickEvent</a>);
<a name="l00122"></a>00122     }
<a name="l00123"></a>00123 }
<a name="l00124"></a>00124 
<a name="l00125"></a>00125 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>
<a name="l00126"></a><a class="code" href="classAtomicSimpleCPU.html#a6f20147a988b52486dc767dc9d33768b">00126</a> <a class="code" href="classAtomicSimpleCPU.html#a6f20147a988b52486dc767dc9d33768b" title="Provide a default implementation of the drain interface that simply returns 0 (draining completed) an...">AtomicSimpleCPU::drain</a>(<a class="code" href="classDrainManager.html" title="This class coordinates draining of a System.">DrainManager</a> *<a class="code" href="namespaceMipsISA.html#afed89bf85db8c823833a4921f0b24ac8">dm</a>)
<a name="l00127"></a>00127 {
<a name="l00128"></a>00128     assert(!<a class="code" href="classAtomicSimpleCPU.html#ae5c6d8831532d01a7052c894cc38bd60" title="Drain manager to use when signaling drain completion.">drain_manager</a>);
<a name="l00129"></a>00129     <span class="keywordflow">if</span> (<a class="code" href="classBaseCPU.html#af2b93a1e156e91265f1b13a4f462c537" title="Determine if the CPU is switched out.">switchedOut</a>())
<a name="l00130"></a>00130         <span class="keywordflow">return</span> 0;
<a name="l00131"></a>00131 
<a name="l00132"></a>00132     <span class="keywordflow">if</span> (!<a class="code" href="classAtomicSimpleCPU.html#a843bc3d42726df6316902cfcbce7af1e" title="Check if a system is in a drained state.">isDrained</a>()) {
<a name="l00133"></a>00133         <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(Drain, <span class="stringliteral">&quot;Requesting drain: %s\n&quot;</span>, <a class="code" href="classBaseSimpleCPU.html#a67965d274ad25d9ce3756fd15fbdaa15">pcState</a>());
<a name="l00134"></a>00134         <a class="code" href="classAtomicSimpleCPU.html#ae5c6d8831532d01a7052c894cc38bd60" title="Drain manager to use when signaling drain completion.">drain_manager</a> = dm;
<a name="l00135"></a>00135         <span class="keywordflow">return</span> 1;
<a name="l00136"></a>00136     } <span class="keywordflow">else</span> {
<a name="l00137"></a>00137         <span class="keywordflow">if</span> (<a class="code" href="classAtomicSimpleCPU.html#a77b35d6b2a4345c6d3971fc64a4d9342">tickEvent</a>.<a class="code" href="classEvent.html#a36bdc2ee73215ed7670a7bfc0f25ab8b" title="Determine if the current event is scheduled.">scheduled</a>())
<a name="l00138"></a>00138             <a class="code" href="classEventManager.html#a92b58a82b7a2bb4935f41bc4d46897b6">deschedule</a>(<a class="code" href="classAtomicSimpleCPU.html#a77b35d6b2a4345c6d3971fc64a4d9342">tickEvent</a>);
<a name="l00139"></a>00139 
<a name="l00140"></a>00140         <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(Drain, <span class="stringliteral">&quot;Not executing microcode, no need to drain.\n&quot;</span>);
<a name="l00141"></a>00141         <span class="keywordflow">return</span> 0;
<a name="l00142"></a>00142     }
<a name="l00143"></a>00143 }
<a name="l00144"></a>00144 
<a name="l00145"></a>00145 <span class="keywordtype">void</span>
<a name="l00146"></a><a class="code" href="classAtomicSimpleCPU.html#ae0fab37c7489e08f7f6def573d58e60d">00146</a> <a class="code" href="classAtomicSimpleCPU.html#ae0fab37c7489e08f7f6def573d58e60d" title="Resume execution after a successful drain.">AtomicSimpleCPU::drainResume</a>()
<a name="l00147"></a>00147 {
<a name="l00148"></a>00148     assert(!<a class="code" href="classAtomicSimpleCPU.html#a77b35d6b2a4345c6d3971fc64a4d9342">tickEvent</a>.<a class="code" href="classEvent.html#a36bdc2ee73215ed7670a7bfc0f25ab8b" title="Determine if the current event is scheduled.">scheduled</a>());
<a name="l00149"></a>00149     assert(!<a class="code" href="classAtomicSimpleCPU.html#ae5c6d8831532d01a7052c894cc38bd60" title="Drain manager to use when signaling drain completion.">drain_manager</a>);
<a name="l00150"></a>00150     <span class="keywordflow">if</span> (<a class="code" href="classBaseCPU.html#af2b93a1e156e91265f1b13a4f462c537" title="Determine if the CPU is switched out.">switchedOut</a>())
<a name="l00151"></a>00151         <span class="keywordflow">return</span>;
<a name="l00152"></a>00152 
<a name="l00153"></a>00153     <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(SimpleCPU, <span class="stringliteral">&quot;Resume\n&quot;</span>);
<a name="l00154"></a>00154     <a class="code" href="classAtomicSimpleCPU.html#ad749d75d8f5f93da2f66e37eaea74514" title="Verify that the system is in a memory mode supported by the CPU.">verifyMemoryMode</a>();
<a name="l00155"></a>00155 
<a name="l00156"></a>00156     assert(!<a class="code" href="classBaseCPU.html#a22178d56f16f4d27c17453771f334a88">threadContexts</a>.empty());
<a name="l00157"></a>00157     <span class="keywordflow">if</span> (<a class="code" href="classBaseCPU.html#a22178d56f16f4d27c17453771f334a88">threadContexts</a>.size() &gt; 1)
<a name="l00158"></a>00158         <a class="code" href="base_2misc_8hh.html#acad519418dbfdd70c1208711e609c80e">fatal</a>(<span class="stringliteral">&quot;The atomic CPU only supports one thread.\n&quot;</span>);
<a name="l00159"></a>00159 
<a name="l00160"></a>00160     <span class="keywordflow">if</span> (<a class="code" href="classBaseSimpleCPU.html#a3b1d88fd3d64c7475fed2adb94515f7d" title="SimpleThread object, provides all the architectural state.">thread</a>-&gt;<a class="code" href="classSimpleThread.html#a544982d84ad9e748ebdd19aed920be6c" title="Returns the status of this thread.">status</a>() == ThreadContext::Active) {
<a name="l00161"></a>00161         <a class="code" href="classEventManager.html#a749a10828b2dd5017a2582960d04e400">schedule</a>(<a class="code" href="classAtomicSimpleCPU.html#a77b35d6b2a4345c6d3971fc64a4d9342">tickEvent</a>, <a class="code" href="classClockedObject.html#afeec54486c377fa6d0825f9d24d64ab3" title="Based on the clock of the object, determine the tick when the next cycle begins, in other words...">nextCycle</a>());
<a name="l00162"></a>00162         <a class="code" href="classBaseSimpleCPU.html#a10a9927ef33b83d6cd4dbb90f2862181">_status</a> = BaseSimpleCPU::Running;
<a name="l00163"></a>00163     } <span class="keywordflow">else</span> {
<a name="l00164"></a>00164         <a class="code" href="classBaseSimpleCPU.html#a10a9927ef33b83d6cd4dbb90f2862181">_status</a> = BaseSimpleCPU::Idle;
<a name="l00165"></a>00165     }
<a name="l00166"></a>00166 
<a name="l00167"></a>00167     <a class="code" href="classBaseCPU.html#aec7be52311ec347359ea6bffc40db74a">system</a>-&gt;<a class="code" href="classSystem.html#ad0fe435fb9766a61216d5eb92d8b2c20">totalNumInsts</a> = 0;
<a name="l00168"></a>00168 }
<a name="l00169"></a>00169 
<a name="l00170"></a>00170 <span class="keywordtype">bool</span>
<a name="l00171"></a><a class="code" href="classAtomicSimpleCPU.html#a16e6c729b7f554c3bab3962407064371">00171</a> <a class="code" href="classAtomicSimpleCPU.html#a16e6c729b7f554c3bab3962407064371" title="Try to complete a drain request.">AtomicSimpleCPU::tryCompleteDrain</a>()
<a name="l00172"></a>00172 {
<a name="l00173"></a>00173     <span class="keywordflow">if</span> (!<a class="code" href="classAtomicSimpleCPU.html#ae5c6d8831532d01a7052c894cc38bd60" title="Drain manager to use when signaling drain completion.">drain_manager</a>)
<a name="l00174"></a>00174         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00175"></a>00175 
<a name="l00176"></a>00176     <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(Drain, <span class="stringliteral">&quot;tryCompleteDrain: %s\n&quot;</span>, <a class="code" href="classBaseSimpleCPU.html#a67965d274ad25d9ce3756fd15fbdaa15">pcState</a>());
<a name="l00177"></a>00177     <span class="keywordflow">if</span> (!<a class="code" href="classAtomicSimpleCPU.html#a843bc3d42726df6316902cfcbce7af1e" title="Check if a system is in a drained state.">isDrained</a>())
<a name="l00178"></a>00178         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00179"></a>00179 
<a name="l00180"></a>00180     <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(Drain, <span class="stringliteral">&quot;CPU done draining, processing drain event\n&quot;</span>);
<a name="l00181"></a>00181     <a class="code" href="classAtomicSimpleCPU.html#ae5c6d8831532d01a7052c894cc38bd60" title="Drain manager to use when signaling drain completion.">drain_manager</a>-&gt;<a class="code" href="classDrainManager.html#abd134e8277be09e702b63f36f6ee31d0" title="Notify the DrainManager that a Drainable object has finished draining.">signalDrainDone</a>();
<a name="l00182"></a>00182     <a class="code" href="classAtomicSimpleCPU.html#ae5c6d8831532d01a7052c894cc38bd60" title="Drain manager to use when signaling drain completion.">drain_manager</a> = NULL;
<a name="l00183"></a>00183 
<a name="l00184"></a>00184     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00185"></a>00185 }
<a name="l00186"></a>00186 
<a name="l00187"></a>00187 
<a name="l00188"></a>00188 <span class="keywordtype">void</span>
<a name="l00189"></a><a class="code" href="classAtomicSimpleCPU.html#af2e886a2e35549d3d0b29a79d65cf907">00189</a> <a class="code" href="classAtomicSimpleCPU.html#af2e886a2e35549d3d0b29a79d65cf907" title="Prepare for another CPU to take over execution.">AtomicSimpleCPU::switchOut</a>()
<a name="l00190"></a>00190 {
<a name="l00191"></a>00191     <a class="code" href="classAtomicSimpleCPU.html#af2e886a2e35549d3d0b29a79d65cf907" title="Prepare for another CPU to take over execution.">BaseSimpleCPU::switchOut</a>();
<a name="l00192"></a>00192 
<a name="l00193"></a>00193     assert(!<a class="code" href="classAtomicSimpleCPU.html#a77b35d6b2a4345c6d3971fc64a4d9342">tickEvent</a>.<a class="code" href="classEvent.html#a36bdc2ee73215ed7670a7bfc0f25ab8b" title="Determine if the current event is scheduled.">scheduled</a>());
<a name="l00194"></a>00194     assert(<a class="code" href="classBaseSimpleCPU.html#a10a9927ef33b83d6cd4dbb90f2862181">_status</a> == <a class="code" href="classBaseSimpleCPU.html#a11b0e96158af07c6e2edfe028774238ca84c8af944b2ef29375b90043bbf68de9">BaseSimpleCPU::Running</a> || <a class="code" href="classBaseSimpleCPU.html#a10a9927ef33b83d6cd4dbb90f2862181">_status</a> == <a class="code" href="classBaseSimpleCPU.html#a11b0e96158af07c6e2edfe028774238cafae0269c6164fdb111af106f09539323">Idle</a>);
<a name="l00195"></a>00195     assert(<a class="code" href="classAtomicSimpleCPU.html#a843bc3d42726df6316902cfcbce7af1e" title="Check if a system is in a drained state.">isDrained</a>());
<a name="l00196"></a>00196 }
<a name="l00197"></a>00197 
<a name="l00198"></a>00198 
<a name="l00199"></a>00199 <span class="keywordtype">void</span>
<a name="l00200"></a><a class="code" href="classAtomicSimpleCPU.html#a659d2944148064049eebf754bd701557">00200</a> <a class="code" href="classAtomicSimpleCPU.html#a659d2944148064049eebf754bd701557" title="Load the state of a CPU from the previous CPU object, invoked on all new CPUs that are about to be sw...">AtomicSimpleCPU::takeOverFrom</a>(<a class="code" href="classBaseCPU.html">BaseCPU</a> *oldCPU)
<a name="l00201"></a>00201 {
<a name="l00202"></a>00202     <a class="code" href="classAtomicSimpleCPU.html#a659d2944148064049eebf754bd701557" title="Load the state of a CPU from the previous CPU object, invoked on all new CPUs that are about to be sw...">BaseSimpleCPU::takeOverFrom</a>(oldCPU);
<a name="l00203"></a>00203 
<a name="l00204"></a>00204     <span class="comment">// The tick event should have been descheduled by drain()</span>
<a name="l00205"></a>00205     assert(!<a class="code" href="classAtomicSimpleCPU.html#a77b35d6b2a4345c6d3971fc64a4d9342">tickEvent</a>.<a class="code" href="classEvent.html#a36bdc2ee73215ed7670a7bfc0f25ab8b" title="Determine if the current event is scheduled.">scheduled</a>());
<a name="l00206"></a>00206 
<a name="l00207"></a>00207     <a class="code" href="classAtomicSimpleCPU.html#ab1d4eecb4d4fad5a281b799a23dd315b">ifetch_req</a>.<a class="code" href="classRequest.html#a0b067551ee420e924c5e2402539df311" title="Set up CPU and thread numbers.">setThreadContext</a>(<a class="code" href="classBaseCPU.html#a512f6e0d7684ff19880a2ff9b6eeeddb">_cpuId</a>, 0); <span class="comment">// Add thread ID if we add MT</span>
<a name="l00208"></a>00208     <a class="code" href="classAtomicSimpleCPU.html#a34d4f70c5792b45e2a6210ef9de99d8b">data_read_req</a>.<a class="code" href="classRequest.html#a0b067551ee420e924c5e2402539df311" title="Set up CPU and thread numbers.">setThreadContext</a>(<a class="code" href="classBaseCPU.html#a512f6e0d7684ff19880a2ff9b6eeeddb">_cpuId</a>, 0); <span class="comment">// Add thread ID here too</span>
<a name="l00209"></a>00209     <a class="code" href="classAtomicSimpleCPU.html#ad536354f472689d58359e5182c6091a5">data_write_req</a>.<a class="code" href="classRequest.html#a0b067551ee420e924c5e2402539df311" title="Set up CPU and thread numbers.">setThreadContext</a>(<a class="code" href="classBaseCPU.html#a512f6e0d7684ff19880a2ff9b6eeeddb">_cpuId</a>, 0); <span class="comment">// Add thread ID here too</span>
<a name="l00210"></a>00210 }
<a name="l00211"></a>00211 
<a name="l00212"></a>00212 <span class="keywordtype">void</span>
<a name="l00213"></a><a class="code" href="classAtomicSimpleCPU.html#ad749d75d8f5f93da2f66e37eaea74514">00213</a> <a class="code" href="classAtomicSimpleCPU.html#ad749d75d8f5f93da2f66e37eaea74514" title="Verify that the system is in a memory mode supported by the CPU.">AtomicSimpleCPU::verifyMemoryMode</a>()<span class="keyword"> const</span>
<a name="l00214"></a>00214 <span class="keyword"></span>{
<a name="l00215"></a>00215     <span class="keywordflow">if</span> (!<a class="code" href="classBaseCPU.html#aec7be52311ec347359ea6bffc40db74a">system</a>-&gt;<a class="code" href="classSystem.html#ac5d30d1c987fe9b89805627dfc70e074" title="Is the system in atomic mode?">isAtomicMode</a>()) {
<a name="l00216"></a>00216         <a class="code" href="base_2misc_8hh.html#acad519418dbfdd70c1208711e609c80e">fatal</a>(<span class="stringliteral">&quot;The atomic CPU requires the memory system to be in &quot;</span>
<a name="l00217"></a>00217               <span class="stringliteral">&quot;&#39;atomic&#39; mode.\n&quot;</span>);
<a name="l00218"></a>00218     }
<a name="l00219"></a>00219 }
<a name="l00220"></a>00220 
<a name="l00221"></a>00221 <span class="keywordtype">void</span>
<a name="l00222"></a><a class="code" href="classAtomicSimpleCPU.html#af8686eed0de7bcb86da509d6d202bdd8">00222</a> <a class="code" href="classAtomicSimpleCPU.html#af8686eed0de7bcb86da509d6d202bdd8" title="Notify the CPU that the indicated context is now active.">AtomicSimpleCPU::activateContext</a>(<a class="code" href="base_2types_8hh.html#ab39b1a4f9dad884694c7a74ed69e6a6b" title="Thread index/ID type.">ThreadID</a> thread_num, <a class="code" href="classCycles.html" title="Cycles is a wrapper class for representing cycle counts, i.e.">Cycles</a> delay)
<a name="l00223"></a>00223 {
<a name="l00224"></a>00224     <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(SimpleCPU, <span class="stringliteral">&quot;ActivateContext %d (%d cycles)\n&quot;</span>, thread_num, delay);
<a name="l00225"></a>00225 
<a name="l00226"></a>00226     assert(thread_num == 0);
<a name="l00227"></a>00227     assert(<a class="code" href="classBaseSimpleCPU.html#a3b1d88fd3d64c7475fed2adb94515f7d" title="SimpleThread object, provides all the architectural state.">thread</a>);
<a name="l00228"></a>00228 
<a name="l00229"></a>00229     assert(<a class="code" href="classBaseSimpleCPU.html#a10a9927ef33b83d6cd4dbb90f2862181">_status</a> == <a class="code" href="classBaseSimpleCPU.html#a11b0e96158af07c6e2edfe028774238cafae0269c6164fdb111af106f09539323">Idle</a>);
<a name="l00230"></a>00230     assert(!<a class="code" href="classAtomicSimpleCPU.html#a77b35d6b2a4345c6d3971fc64a4d9342">tickEvent</a>.<a class="code" href="classEvent.html#a36bdc2ee73215ed7670a7bfc0f25ab8b" title="Determine if the current event is scheduled.">scheduled</a>());
<a name="l00231"></a>00231 
<a name="l00232"></a>00232     <a class="code" href="classBaseSimpleCPU.html#aaf55ab0bb573e20c49c80ad8310a1214">notIdleFraction</a>++;
<a name="l00233"></a>00233     <a class="code" href="classBaseCPU.html#a205aff3cc2e726632f492ccd4f45d3ca">numCycles</a> += <a class="code" href="classClockedObject.html#a0ed1c09106348a3fcd72ea19909256c1">ticksToCycles</a>(<a class="code" href="classBaseSimpleCPU.html#a3b1d88fd3d64c7475fed2adb94515f7d" title="SimpleThread object, provides all the architectural state.">thread</a>-&gt;<a class="code" href="structThreadState.html#a57b351bee1da4b04f1141684d8dc608d" title="Last time activate was called on this thread.">lastActivate</a> - <a class="code" href="classBaseSimpleCPU.html#a3b1d88fd3d64c7475fed2adb94515f7d" title="SimpleThread object, provides all the architectural state.">thread</a>-&gt;<a class="code" href="structThreadState.html#a3bb0a423d8308f6cacf1686592cdb46a" title="Last time suspend was called on this thread.">lastSuspend</a>);
<a name="l00234"></a>00234 
<a name="l00235"></a>00235     <span class="comment">//Make sure ticks are still on multiples of cycles</span>
<a name="l00236"></a>00236     <a class="code" href="classEventManager.html#a749a10828b2dd5017a2582960d04e400">schedule</a>(<a class="code" href="classAtomicSimpleCPU.html#a77b35d6b2a4345c6d3971fc64a4d9342">tickEvent</a>, <a class="code" href="classClockedObject.html#a7c1f64c925f158530be84323a503dbb7" title="Determine the tick when a cycle begins, by default the current one, but the argument also enables the...">clockEdge</a>(delay));
<a name="l00237"></a>00237     <a class="code" href="classBaseSimpleCPU.html#a10a9927ef33b83d6cd4dbb90f2862181">_status</a> = BaseSimpleCPU::Running;
<a name="l00238"></a>00238 }
<a name="l00239"></a>00239 
<a name="l00240"></a>00240 
<a name="l00241"></a>00241 <span class="keywordtype">void</span>
<a name="l00242"></a><a class="code" href="classAtomicSimpleCPU.html#aba4433a3317488ddcd45d700cf5097d7">00242</a> <a class="code" href="classAtomicSimpleCPU.html#aba4433a3317488ddcd45d700cf5097d7" title="Notify the CPU that the indicated context is now suspended.">AtomicSimpleCPU::suspendContext</a>(<a class="code" href="base_2types_8hh.html#ab39b1a4f9dad884694c7a74ed69e6a6b" title="Thread index/ID type.">ThreadID</a> thread_num)
<a name="l00243"></a>00243 {
<a name="l00244"></a>00244     <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(SimpleCPU, <span class="stringliteral">&quot;SuspendContext %d\n&quot;</span>, thread_num);
<a name="l00245"></a>00245 
<a name="l00246"></a>00246     assert(thread_num == 0);
<a name="l00247"></a>00247     assert(<a class="code" href="classBaseSimpleCPU.html#a3b1d88fd3d64c7475fed2adb94515f7d" title="SimpleThread object, provides all the architectural state.">thread</a>);
<a name="l00248"></a>00248 
<a name="l00249"></a>00249     <span class="keywordflow">if</span> (<a class="code" href="classBaseSimpleCPU.html#a10a9927ef33b83d6cd4dbb90f2862181">_status</a> == <a class="code" href="classBaseSimpleCPU.html#a11b0e96158af07c6e2edfe028774238cafae0269c6164fdb111af106f09539323">Idle</a>)
<a name="l00250"></a>00250         <span class="keywordflow">return</span>;
<a name="l00251"></a>00251 
<a name="l00252"></a>00252     assert(<a class="code" href="classBaseSimpleCPU.html#a10a9927ef33b83d6cd4dbb90f2862181">_status</a> == <a class="code" href="classBaseSimpleCPU.html#a11b0e96158af07c6e2edfe028774238ca84c8af944b2ef29375b90043bbf68de9">BaseSimpleCPU::Running</a>);
<a name="l00253"></a>00253 
<a name="l00254"></a>00254     <span class="comment">// tick event may not be scheduled if this gets called from inside</span>
<a name="l00255"></a>00255     <span class="comment">// an instruction&#39;s execution, e.g. &quot;quiesce&quot;</span>
<a name="l00256"></a>00256     <span class="keywordflow">if</span> (<a class="code" href="classAtomicSimpleCPU.html#a77b35d6b2a4345c6d3971fc64a4d9342">tickEvent</a>.<a class="code" href="classEvent.html#a36bdc2ee73215ed7670a7bfc0f25ab8b" title="Determine if the current event is scheduled.">scheduled</a>())
<a name="l00257"></a>00257         <a class="code" href="classEventManager.html#a92b58a82b7a2bb4935f41bc4d46897b6">deschedule</a>(<a class="code" href="classAtomicSimpleCPU.html#a77b35d6b2a4345c6d3971fc64a4d9342">tickEvent</a>);
<a name="l00258"></a>00258 
<a name="l00259"></a>00259     <a class="code" href="classBaseSimpleCPU.html#aaf55ab0bb573e20c49c80ad8310a1214">notIdleFraction</a>--;
<a name="l00260"></a>00260     <a class="code" href="classBaseSimpleCPU.html#a10a9927ef33b83d6cd4dbb90f2862181">_status</a> = Idle;
<a name="l00261"></a>00261 }
<a name="l00262"></a>00262 
<a name="l00263"></a>00263 
<a name="l00264"></a>00264 <a class="code" href="classRefCountingPtr.html">Fault</a>
<a name="l00265"></a><a class="code" href="classAtomicSimpleCPU.html#a93f8747e50317589d7394f7a82dfecfe">00265</a> <a class="code" href="classAtomicSimpleCPU.html#a93f8747e50317589d7394f7a82dfecfe">AtomicSimpleCPU::readMem</a>(<a class="code" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232" title="Address type This will probably be moved somewhere else in the near future.">Addr</a> <a class="code" href="namespaceX86ISA.html#a79b5c08c190167d17c9b9b3fd40112f6">addr</a>, uint8_t * data,
<a name="l00266"></a>00266                          <span class="keywordtype">unsigned</span> size, <span class="keywordtype">unsigned</span> flags)
<a name="l00267"></a>00267 {
<a name="l00268"></a>00268     <span class="comment">// use the CPU&#39;s statically allocated read request and packet objects</span>
<a name="l00269"></a>00269     <a class="code" href="classRequest.html">Request</a> *req = &amp;<a class="code" href="classAtomicSimpleCPU.html#a34d4f70c5792b45e2a6210ef9de99d8b">data_read_req</a>;
<a name="l00270"></a>00270 
<a name="l00271"></a>00271     <span class="keywordflow">if</span> (<a class="code" href="classBaseSimpleCPU.html#a1c5b42da4bb058bf584c14d4efe4e456">traceData</a>) {
<a name="l00272"></a>00272         <a class="code" href="classBaseSimpleCPU.html#a1c5b42da4bb058bf584c14d4efe4e456">traceData</a>-&gt;<a class="code" href="classTrace_1_1InstRecord.html#a83742726105cd51fccca58d2a098c59f">setAddr</a>(addr);
<a name="l00273"></a>00273     }
<a name="l00274"></a>00274 
<a name="l00275"></a>00275     <span class="comment">//The block size of our peer.</span>
<a name="l00276"></a>00276     <span class="keywordtype">unsigned</span> blockSize = <a class="code" href="classAtomicSimpleCPU.html#a40e95ebf12757f1685fee06d33452260">dcachePort</a>.peerBlockSize();
<a name="l00277"></a>00277     <span class="comment">//The size of the data we&#39;re trying to read.</span>
<a name="l00278"></a>00278     <span class="keywordtype">int</span> fullSize = size;
<a name="l00279"></a>00279 
<a name="l00280"></a>00280     <span class="comment">//The address of the second part of this access if it needs to be split</span>
<a name="l00281"></a>00281     <span class="comment">//across a cache line boundary.</span>
<a name="l00282"></a>00282     <a class="code" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232" title="Address type This will probably be moved somewhere else in the near future.">Addr</a> secondAddr = <a class="code" href="intmath_8hh.html#a343c19b0ae885d5f3c7960987096e9d5">roundDown</a>(addr + size - 1, blockSize);
<a name="l00283"></a>00283 
<a name="l00284"></a>00284     <span class="keywordflow">if</span> (secondAddr &gt; addr)
<a name="l00285"></a>00285         size = secondAddr - addr;
<a name="l00286"></a>00286 
<a name="l00287"></a>00287     <a class="code" href="classAtomicSimpleCPU.html#a547478889037038166417a298d5cf430">dcache_latency</a> = 0;
<a name="l00288"></a>00288 
<a name="l00289"></a>00289     <span class="keywordflow">while</span> (1) {
<a name="l00290"></a>00290         req-&gt;<a class="code" href="classRequest.html#a09207c906138b83b0b442928e998e63d" title="Set up a virtual (e.g., CPU) request in a previously allocated Request object.">setVirt</a>(0, addr, size, flags, <a class="code" href="classBaseCPU.html#ad6256793229f94e3f4f1d9f7569e707d" title="Reads this CPU&amp;#39;s unique data requestor ID.">dataMasterId</a>(), <a class="code" href="classBaseSimpleCPU.html#a3b1d88fd3d64c7475fed2adb94515f7d" title="SimpleThread object, provides all the architectural state.">thread</a>-&gt;<a class="code" href="classSimpleThread.html#aac01d6afdb95c2a68442b54255549c79">pcState</a>().instAddr());
<a name="l00291"></a>00291 
<a name="l00292"></a>00292         <span class="comment">// translate to physical address</span>
<a name="l00293"></a>00293         <a class="code" href="classRefCountingPtr.html">Fault</a> fault = <a class="code" href="classBaseSimpleCPU.html#a3b1d88fd3d64c7475fed2adb94515f7d" title="SimpleThread object, provides all the architectural state.">thread</a>-&gt;<a class="code" href="classSimpleThread.html#a62d84f3353aa11c12fa51020ff3d9a83">dtb</a>-&gt;translateAtomic(req, <a class="code" href="classBaseSimpleCPU.html#a1d94ea1eaa23dd214f48d3833601941d" title="ThreadContext object, provides an interface for external objects to modify this thread&amp;#39;s state...">tc</a>, <a class="code" href="classBaseTLB.html#a26b67ef35b9f92e337acf48571c7585eaf4cd684f5d76a9d7d92f583393d1655f">BaseTLB::Read</a>);
<a name="l00294"></a>00294 
<a name="l00295"></a>00295         <span class="comment">// Now do the access.</span>
<a name="l00296"></a>00296         <span class="keywordflow">if</span> (fault == <a class="code" href="fault__fwd_8hh.html#ab8ce3b69a6737f63fcdcf99910feb153">NoFault</a> &amp;&amp; !req-&gt;<a class="code" href="classRequest.html#ab5c7328019f59c101363cfb6b0cb51f2" title="Accessor for flags.">getFlags</a>().<a class="code" href="classFlags.html#a8739f6353a29e0db4f16421f93b3f0ca">isSet</a>(<a class="code" href="classRequest.html#afb49cdea56ecdaff7974ea3649ade5f1" title="The request should not cause a memory access.">Request::NO_ACCESS</a>)) {
<a name="l00297"></a>00297             <a class="code" href="classPacket.html" title="A Packet is used to encapsulate a transfer between two objects in the memory system (e...">Packet</a> pkt = <a class="code" href="classPacket.html" title="A Packet is used to encapsulate a transfer between two objects in the memory system (e...">Packet</a>(req,
<a name="l00298"></a>00298                                 req-&gt;<a class="code" href="classRequest.html#aae15c8d8bda6d4a094c273e812e7f180">isLLSC</a>() ? <a class="code" href="classMemCmd.html#ae5c39c2de0ad998b5176bc519b358102ad31f1e0a991481fdf8bdf9bdb10ed677">MemCmd::LoadLockedReq</a> :
<a name="l00299"></a>00299                                 MemCmd::ReadReq);
<a name="l00300"></a>00300             pkt.<a class="code" href="classPacket.html#aa81ea5325a7aa403fa94f2d84f6f4236" title="Set the data pointer to the following value that should not be freed.">dataStatic</a>(data);
<a name="l00301"></a>00301 
<a name="l00302"></a>00302             <span class="keywordflow">if</span> (req-&gt;<a class="code" href="classRequest.html#a8f098b383efe977a06e749c6cb6a8018">isMmappedIpr</a>())
<a name="l00303"></a>00303                 <a class="code" href="classAtomicSimpleCPU.html#a547478889037038166417a298d5cf430">dcache_latency</a> += <a class="code" href="namespaceAlphaISA.html#af38328bf4f81800355569f564ad9a2ae">TheISA::handleIprRead</a>(<a class="code" href="classBaseSimpleCPU.html#a3b1d88fd3d64c7475fed2adb94515f7d" title="SimpleThread object, provides all the architectural state.">thread</a>-&gt;<a class="code" href="classSimpleThread.html#a7da3f5e0fcea7bb73fce014f93bf2c0c" title="Returns the pointer to this SimpleThread&amp;#39;s ThreadContext.">getTC</a>(), &amp;pkt);
<a name="l00304"></a>00304             <span class="keywordflow">else</span> {
<a name="l00305"></a>00305                 <span class="keywordflow">if</span> (<a class="code" href="classAtomicSimpleCPU.html#a2617122e0bc6eac8d5fb651d4c506f64">fastmem</a> &amp;&amp; <a class="code" href="classBaseCPU.html#aec7be52311ec347359ea6bffc40db74a">system</a>-&gt;<a class="code" href="classSystem.html#a59ccf6b92713bf241fbf6c9238db86a4" title="Check if a physical address is within a range of a memory that is part of the global address map...">isMemAddr</a>(pkt.<a class="code" href="classPacket.html#a1c04785186ba5aa70a40cac9b2bfc86e">getAddr</a>()))
<a name="l00306"></a>00306                     <a class="code" href="classBaseCPU.html#aec7be52311ec347359ea6bffc40db74a">system</a>-&gt;<a class="code" href="classSystem.html#a1bcb5c7e0e5029f9c80bb747a0257d8a" title="Get a pointer to access the physical memory of the system.">getPhysMem</a>().<a class="code" href="classPhysicalMemory.html#a37b3796dfbc3dfd693675e79052b2deb" title="Perform an untimed memory access and update all the state (e.g.">access</a>(&amp;pkt);
<a name="l00307"></a>00307                 <span class="keywordflow">else</span>
<a name="l00308"></a>00308                     <a class="code" href="classAtomicSimpleCPU.html#a547478889037038166417a298d5cf430">dcache_latency</a> += <a class="code" href="classAtomicSimpleCPU.html#a40e95ebf12757f1685fee06d33452260">dcachePort</a>.sendAtomic(&amp;pkt);
<a name="l00309"></a>00309             }
<a name="l00310"></a>00310             <a class="code" href="classAtomicSimpleCPU.html#a42f64c0d18992606b34c59a70c1fc9a6">dcache_access</a> = <span class="keyword">true</span>;
<a name="l00311"></a>00311 
<a name="l00312"></a>00312             assert(!pkt.<a class="code" href="classPacket.html#a1ea5391da77928d157f79bebe80f6a97">isError</a>());
<a name="l00313"></a>00313 
<a name="l00314"></a>00314             <span class="keywordflow">if</span> (req-&gt;<a class="code" href="classRequest.html#aae15c8d8bda6d4a094c273e812e7f180">isLLSC</a>()) {
<a name="l00315"></a>00315                 <a class="code" href="namespaceAlphaISA.html#a00333a272d42606a01cc33c81999a58b">TheISA::handleLockedRead</a>(<a class="code" href="classBaseSimpleCPU.html#a3b1d88fd3d64c7475fed2adb94515f7d" title="SimpleThread object, provides all the architectural state.">thread</a>, req);
<a name="l00316"></a>00316             }
<a name="l00317"></a>00317         }
<a name="l00318"></a>00318 
<a name="l00319"></a>00319         <span class="comment">//If there&#39;s a fault, return it</span>
<a name="l00320"></a>00320         <span class="keywordflow">if</span> (fault != <a class="code" href="fault__fwd_8hh.html#ab8ce3b69a6737f63fcdcf99910feb153">NoFault</a>) {
<a name="l00321"></a>00321             <span class="keywordflow">if</span> (req-&gt;<a class="code" href="classRequest.html#a2ce7bb6276d358e2b49abd30aae0431a">isPrefetch</a>()) {
<a name="l00322"></a>00322                 <span class="keywordflow">return</span> <a class="code" href="fault__fwd_8hh.html#ab8ce3b69a6737f63fcdcf99910feb153">NoFault</a>;
<a name="l00323"></a>00323             } <span class="keywordflow">else</span> {
<a name="l00324"></a>00324                 <span class="keywordflow">return</span> fault;
<a name="l00325"></a>00325             }
<a name="l00326"></a>00326         }
<a name="l00327"></a>00327 
<a name="l00328"></a>00328         <span class="comment">//If we don&#39;t need to access a second cache line, stop now.</span>
<a name="l00329"></a>00329         <span class="keywordflow">if</span> (secondAddr &lt;= addr)
<a name="l00330"></a>00330         {
<a name="l00331"></a>00331             <span class="keywordflow">if</span> (req-&gt;<a class="code" href="classRequest.html#a66108befdaf1e6bebe114cc38161c084">isLocked</a>() &amp;&amp; fault == <a class="code" href="fault__fwd_8hh.html#ab8ce3b69a6737f63fcdcf99910feb153">NoFault</a>) {
<a name="l00332"></a>00332                 assert(!<a class="code" href="classAtomicSimpleCPU.html#a31dcb20025a91e42a4ae233e30e71854">locked</a>);
<a name="l00333"></a>00333                 <a class="code" href="classAtomicSimpleCPU.html#a31dcb20025a91e42a4ae233e30e71854">locked</a> = <span class="keyword">true</span>;
<a name="l00334"></a>00334             }
<a name="l00335"></a>00335             <span class="keywordflow">return</span> fault;
<a name="l00336"></a>00336         }
<a name="l00337"></a>00337 
<a name="l00338"></a>00338         <span class="comment">/*</span>
<a name="l00339"></a>00339 <span class="comment">         * Set up for accessing the second cache line.</span>
<a name="l00340"></a>00340 <span class="comment">         */</span>
<a name="l00341"></a>00341 
<a name="l00342"></a>00342         <span class="comment">//Move the pointer we&#39;re reading into to the correct location.</span>
<a name="l00343"></a>00343         data += size;
<a name="l00344"></a>00344         <span class="comment">//Adjust the size to get the remaining bytes.</span>
<a name="l00345"></a>00345         size = addr + fullSize - secondAddr;
<a name="l00346"></a>00346         <span class="comment">//And access the right address.</span>
<a name="l00347"></a>00347         addr = secondAddr;
<a name="l00348"></a>00348     }
<a name="l00349"></a>00349 }
<a name="l00350"></a>00350 
<a name="l00351"></a>00351 
<a name="l00352"></a>00352 <a class="code" href="classRefCountingPtr.html">Fault</a>
<a name="l00353"></a><a class="code" href="classAtomicSimpleCPU.html#a96cfaa75cdf8bf2b79dc5d9fdd5b618e">00353</a> <a class="code" href="classAtomicSimpleCPU.html#a96cfaa75cdf8bf2b79dc5d9fdd5b618e">AtomicSimpleCPU::writeMem</a>(uint8_t *data, <span class="keywordtype">unsigned</span> size,
<a name="l00354"></a>00354                           <a class="code" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232" title="Address type This will probably be moved somewhere else in the near future.">Addr</a> <a class="code" href="namespaceX86ISA.html#a79b5c08c190167d17c9b9b3fd40112f6">addr</a>, <span class="keywordtype">unsigned</span> flags, uint64_t *res)
<a name="l00355"></a>00355 {
<a name="l00356"></a>00356     <span class="comment">// use the CPU&#39;s statically allocated write request and packet objects</span>
<a name="l00357"></a>00357     <a class="code" href="classRequest.html">Request</a> *req = &amp;<a class="code" href="classAtomicSimpleCPU.html#ad536354f472689d58359e5182c6091a5">data_write_req</a>;
<a name="l00358"></a>00358 
<a name="l00359"></a>00359     <span class="keywordflow">if</span> (<a class="code" href="classBaseSimpleCPU.html#a1c5b42da4bb058bf584c14d4efe4e456">traceData</a>) {
<a name="l00360"></a>00360         <a class="code" href="classBaseSimpleCPU.html#a1c5b42da4bb058bf584c14d4efe4e456">traceData</a>-&gt;<a class="code" href="classTrace_1_1InstRecord.html#a83742726105cd51fccca58d2a098c59f">setAddr</a>(addr);
<a name="l00361"></a>00361     }
<a name="l00362"></a>00362 
<a name="l00363"></a>00363     <span class="comment">//The block size of our peer.</span>
<a name="l00364"></a>00364     <span class="keywordtype">unsigned</span> blockSize = <a class="code" href="classAtomicSimpleCPU.html#a40e95ebf12757f1685fee06d33452260">dcachePort</a>.peerBlockSize();
<a name="l00365"></a>00365     <span class="comment">//The size of the data we&#39;re trying to read.</span>
<a name="l00366"></a>00366     <span class="keywordtype">int</span> fullSize = size;
<a name="l00367"></a>00367 
<a name="l00368"></a>00368     <span class="comment">//The address of the second part of this access if it needs to be split</span>
<a name="l00369"></a>00369     <span class="comment">//across a cache line boundary.</span>
<a name="l00370"></a>00370     <a class="code" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232" title="Address type This will probably be moved somewhere else in the near future.">Addr</a> secondAddr = <a class="code" href="intmath_8hh.html#a343c19b0ae885d5f3c7960987096e9d5">roundDown</a>(addr + size - 1, blockSize);
<a name="l00371"></a>00371 
<a name="l00372"></a>00372     <span class="keywordflow">if</span>(secondAddr &gt; addr)
<a name="l00373"></a>00373         size = secondAddr - addr;
<a name="l00374"></a>00374 
<a name="l00375"></a>00375     <a class="code" href="classAtomicSimpleCPU.html#a547478889037038166417a298d5cf430">dcache_latency</a> = 0;
<a name="l00376"></a>00376 
<a name="l00377"></a>00377     <span class="keywordflow">while</span>(1) {
<a name="l00378"></a>00378         req-&gt;<a class="code" href="classRequest.html#a09207c906138b83b0b442928e998e63d" title="Set up a virtual (e.g., CPU) request in a previously allocated Request object.">setVirt</a>(0, addr, size, flags, <a class="code" href="classBaseCPU.html#ad6256793229f94e3f4f1d9f7569e707d" title="Reads this CPU&amp;#39;s unique data requestor ID.">dataMasterId</a>(), <a class="code" href="classBaseSimpleCPU.html#a3b1d88fd3d64c7475fed2adb94515f7d" title="SimpleThread object, provides all the architectural state.">thread</a>-&gt;<a class="code" href="classSimpleThread.html#aac01d6afdb95c2a68442b54255549c79">pcState</a>().instAddr());
<a name="l00379"></a>00379 
<a name="l00380"></a>00380         <span class="comment">// translate to physical address</span>
<a name="l00381"></a>00381         <a class="code" href="classRefCountingPtr.html">Fault</a> fault = <a class="code" href="classBaseSimpleCPU.html#a3b1d88fd3d64c7475fed2adb94515f7d" title="SimpleThread object, provides all the architectural state.">thread</a>-&gt;<a class="code" href="classSimpleThread.html#a62d84f3353aa11c12fa51020ff3d9a83">dtb</a>-&gt;translateAtomic(req, <a class="code" href="classBaseSimpleCPU.html#a1d94ea1eaa23dd214f48d3833601941d" title="ThreadContext object, provides an interface for external objects to modify this thread&amp;#39;s state...">tc</a>, <a class="code" href="classBaseTLB.html#a26b67ef35b9f92e337acf48571c7585ea19df812c62f939e92e6d395572c900b5">BaseTLB::Write</a>);
<a name="l00382"></a>00382 
<a name="l00383"></a>00383         <span class="comment">// Now do the access.</span>
<a name="l00384"></a>00384         <span class="keywordflow">if</span> (fault == <a class="code" href="fault__fwd_8hh.html#ab8ce3b69a6737f63fcdcf99910feb153">NoFault</a>) {
<a name="l00385"></a>00385             <a class="code" href="classMemCmd.html">MemCmd</a> cmd = MemCmd::WriteReq; <span class="comment">// default</span>
<a name="l00386"></a>00386             <span class="keywordtype">bool</span> do_access = <span class="keyword">true</span>;  <span class="comment">// flag to suppress cache access</span>
<a name="l00387"></a>00387 
<a name="l00388"></a>00388             <span class="keywordflow">if</span> (req-&gt;<a class="code" href="classRequest.html#aae15c8d8bda6d4a094c273e812e7f180">isLLSC</a>()) {
<a name="l00389"></a>00389                 cmd = MemCmd::StoreCondReq;
<a name="l00390"></a>00390                 do_access = <a class="code" href="namespaceAlphaISA.html#afe89448e9773892287b1caf80a0df12b">TheISA::handleLockedWrite</a>(<a class="code" href="classBaseSimpleCPU.html#a3b1d88fd3d64c7475fed2adb94515f7d" title="SimpleThread object, provides all the architectural state.">thread</a>, req);
<a name="l00391"></a>00391             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (req-&gt;<a class="code" href="classRequest.html#acf031f0e7e61f736330905bae2fc5437">isSwap</a>()) {
<a name="l00392"></a>00392                 cmd = MemCmd::SwapReq;
<a name="l00393"></a>00393                 <span class="keywordflow">if</span> (req-&gt;<a class="code" href="classRequest.html#a733c9d864f85de3116301d5922ccdbff">isCondSwap</a>()) {
<a name="l00394"></a>00394                     assert(res);
<a name="l00395"></a>00395                     req-&gt;<a class="code" href="classRequest.html#a8b10515d83f9c5504a987b920c526c2c" title="Accessor function for store conditional return value.">setExtraData</a>(*res);
<a name="l00396"></a>00396                 }
<a name="l00397"></a>00397             }
<a name="l00398"></a>00398 
<a name="l00399"></a>00399             <span class="keywordflow">if</span> (do_access &amp;&amp; !req-&gt;<a class="code" href="classRequest.html#ab5c7328019f59c101363cfb6b0cb51f2" title="Accessor for flags.">getFlags</a>().<a class="code" href="classFlags.html#a8739f6353a29e0db4f16421f93b3f0ca">isSet</a>(<a class="code" href="classRequest.html#afb49cdea56ecdaff7974ea3649ade5f1" title="The request should not cause a memory access.">Request::NO_ACCESS</a>)) {
<a name="l00400"></a>00400                 <a class="code" href="classPacket.html" title="A Packet is used to encapsulate a transfer between two objects in the memory system (e...">Packet</a> pkt = <a class="code" href="classPacket.html" title="A Packet is used to encapsulate a transfer between two objects in the memory system (e...">Packet</a>(req, cmd);
<a name="l00401"></a>00401                 pkt.<a class="code" href="classPacket.html#aa81ea5325a7aa403fa94f2d84f6f4236" title="Set the data pointer to the following value that should not be freed.">dataStatic</a>(data);
<a name="l00402"></a>00402 
<a name="l00403"></a>00403                 <span class="keywordflow">if</span> (req-&gt;<a class="code" href="classRequest.html#a8f098b383efe977a06e749c6cb6a8018">isMmappedIpr</a>()) {
<a name="l00404"></a>00404                     <a class="code" href="classAtomicSimpleCPU.html#a547478889037038166417a298d5cf430">dcache_latency</a> +=
<a name="l00405"></a>00405                         <a class="code" href="namespaceAlphaISA.html#ab5b2018349c01ed3a5a1506d2dffadbe">TheISA::handleIprWrite</a>(<a class="code" href="classBaseSimpleCPU.html#a3b1d88fd3d64c7475fed2adb94515f7d" title="SimpleThread object, provides all the architectural state.">thread</a>-&gt;<a class="code" href="classSimpleThread.html#a7da3f5e0fcea7bb73fce014f93bf2c0c" title="Returns the pointer to this SimpleThread&amp;#39;s ThreadContext.">getTC</a>(), &amp;pkt);
<a name="l00406"></a>00406                 } <span class="keywordflow">else</span> {
<a name="l00407"></a>00407                     <span class="keywordflow">if</span> (<a class="code" href="classAtomicSimpleCPU.html#a2617122e0bc6eac8d5fb651d4c506f64">fastmem</a> &amp;&amp; <a class="code" href="classBaseCPU.html#aec7be52311ec347359ea6bffc40db74a">system</a>-&gt;<a class="code" href="classSystem.html#a59ccf6b92713bf241fbf6c9238db86a4" title="Check if a physical address is within a range of a memory that is part of the global address map...">isMemAddr</a>(pkt.<a class="code" href="classPacket.html#a1c04785186ba5aa70a40cac9b2bfc86e">getAddr</a>()))
<a name="l00408"></a>00408                         <a class="code" href="classBaseCPU.html#aec7be52311ec347359ea6bffc40db74a">system</a>-&gt;<a class="code" href="classSystem.html#a1bcb5c7e0e5029f9c80bb747a0257d8a" title="Get a pointer to access the physical memory of the system.">getPhysMem</a>().<a class="code" href="classPhysicalMemory.html#a37b3796dfbc3dfd693675e79052b2deb" title="Perform an untimed memory access and update all the state (e.g.">access</a>(&amp;pkt);
<a name="l00409"></a>00409                     <span class="keywordflow">else</span>
<a name="l00410"></a>00410                         <a class="code" href="classAtomicSimpleCPU.html#a547478889037038166417a298d5cf430">dcache_latency</a> += <a class="code" href="classAtomicSimpleCPU.html#a40e95ebf12757f1685fee06d33452260">dcachePort</a>.sendAtomic(&amp;pkt);
<a name="l00411"></a>00411                 }
<a name="l00412"></a>00412                 <a class="code" href="classAtomicSimpleCPU.html#a42f64c0d18992606b34c59a70c1fc9a6">dcache_access</a> = <span class="keyword">true</span>;
<a name="l00413"></a>00413                 assert(!pkt.<a class="code" href="classPacket.html#a1ea5391da77928d157f79bebe80f6a97">isError</a>());
<a name="l00414"></a>00414 
<a name="l00415"></a>00415                 <span class="keywordflow">if</span> (req-&gt;<a class="code" href="classRequest.html#acf031f0e7e61f736330905bae2fc5437">isSwap</a>()) {
<a name="l00416"></a>00416                     assert(res);
<a name="l00417"></a>00417                     memcpy(res, pkt.<a class="code" href="classPacket.html#ad9552d30d60e5425e0a66b5c4e5c85d8" title="get a pointer to the data ptr.">getPtr</a>&lt;uint8_t&gt;(), fullSize);
<a name="l00418"></a>00418                 }
<a name="l00419"></a>00419             }
<a name="l00420"></a>00420 
<a name="l00421"></a>00421             <span class="keywordflow">if</span> (res &amp;&amp; !req-&gt;<a class="code" href="classRequest.html#acf031f0e7e61f736330905bae2fc5437">isSwap</a>()) {
<a name="l00422"></a>00422                 *res = req-&gt;<a class="code" href="classRequest.html#a8e0656fded5faa62241c3174b6f396a0" title="Accessor function for store conditional return value.">getExtraData</a>();
<a name="l00423"></a>00423             }
<a name="l00424"></a>00424         }
<a name="l00425"></a>00425 
<a name="l00426"></a>00426         <span class="comment">//If there&#39;s a fault or we don&#39;t need to access a second cache line,</span>
<a name="l00427"></a>00427         <span class="comment">//stop now.</span>
<a name="l00428"></a>00428         <span class="keywordflow">if</span> (fault != <a class="code" href="fault__fwd_8hh.html#ab8ce3b69a6737f63fcdcf99910feb153">NoFault</a> || secondAddr &lt;= addr)
<a name="l00429"></a>00429         {
<a name="l00430"></a>00430             <span class="keywordflow">if</span> (req-&gt;<a class="code" href="classRequest.html#a66108befdaf1e6bebe114cc38161c084">isLocked</a>() &amp;&amp; fault == <a class="code" href="fault__fwd_8hh.html#ab8ce3b69a6737f63fcdcf99910feb153">NoFault</a>) {
<a name="l00431"></a>00431                 assert(<a class="code" href="classAtomicSimpleCPU.html#a31dcb20025a91e42a4ae233e30e71854">locked</a>);
<a name="l00432"></a>00432                 <a class="code" href="classAtomicSimpleCPU.html#a31dcb20025a91e42a4ae233e30e71854">locked</a> = <span class="keyword">false</span>;
<a name="l00433"></a>00433             }
<a name="l00434"></a>00434             <span class="keywordflow">if</span> (fault != <a class="code" href="fault__fwd_8hh.html#ab8ce3b69a6737f63fcdcf99910feb153">NoFault</a> &amp;&amp; req-&gt;<a class="code" href="classRequest.html#a2ce7bb6276d358e2b49abd30aae0431a">isPrefetch</a>()) {
<a name="l00435"></a>00435                 <span class="keywordflow">return</span> <a class="code" href="fault__fwd_8hh.html#ab8ce3b69a6737f63fcdcf99910feb153">NoFault</a>;
<a name="l00436"></a>00436             } <span class="keywordflow">else</span> {
<a name="l00437"></a>00437                 <span class="keywordflow">return</span> fault;
<a name="l00438"></a>00438             }
<a name="l00439"></a>00439         }
<a name="l00440"></a>00440 
<a name="l00441"></a>00441         <span class="comment">/*</span>
<a name="l00442"></a>00442 <span class="comment">         * Set up for accessing the second cache line.</span>
<a name="l00443"></a>00443 <span class="comment">         */</span>
<a name="l00444"></a>00444 
<a name="l00445"></a>00445         <span class="comment">//Move the pointer we&#39;re reading into to the correct location.</span>
<a name="l00446"></a>00446         data += size;
<a name="l00447"></a>00447         <span class="comment">//Adjust the size to get the remaining bytes.</span>
<a name="l00448"></a>00448         size = addr + fullSize - secondAddr;
<a name="l00449"></a>00449         <span class="comment">//And access the right address.</span>
<a name="l00450"></a>00450         addr = secondAddr;
<a name="l00451"></a>00451     }
<a name="l00452"></a>00452 }
<a name="l00453"></a>00453 
<a name="l00454"></a>00454 
<a name="l00455"></a>00455 <span class="keywordtype">void</span>
<a name="l00456"></a><a class="code" href="classAtomicSimpleCPU.html#a3b5859c96b689d7c6e8d3df2d0bb1de5">00456</a> <a class="code" href="classAtomicSimpleCPU.html#a3b5859c96b689d7c6e8d3df2d0bb1de5">AtomicSimpleCPU::tick</a>()
<a name="l00457"></a>00457 {
<a name="l00458"></a>00458     <a class="code" href="trace_8hh.html#aefe58fddf89e41edd783bf4c3e31d2c3">DPRINTF</a>(SimpleCPU, <span class="stringliteral">&quot;Tick\n&quot;</span>);
<a name="l00459"></a>00459 
<a name="l00460"></a>00460     <a class="code" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643" title="Tick count type.">Tick</a> latency = 0;
<a name="l00461"></a>00461 
<a name="l00462"></a>00462     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> <a class="code" href="namespaceArmISA.html#a07402644ed55c19e1a116116c548c2ac">i</a> = 0; <a class="code" href="namespaceArmISA.html#a07402644ed55c19e1a116116c548c2ac">i</a> &lt; <a class="code" href="classAtomicSimpleCPU.html#a247f5d16ecdf2e511bb6d8d1de8207d3">width</a> || <a class="code" href="classAtomicSimpleCPU.html#a31dcb20025a91e42a4ae233e30e71854">locked</a>; ++<a class="code" href="namespaceArmISA.html#a07402644ed55c19e1a116116c548c2ac">i</a>) {
<a name="l00463"></a>00463         <a class="code" href="classBaseCPU.html#a205aff3cc2e726632f492ccd4f45d3ca">numCycles</a>++;
<a name="l00464"></a>00464 
<a name="l00465"></a>00465         <span class="keywordflow">if</span> (!<a class="code" href="classBaseSimpleCPU.html#a8bfe7f75498271dfe7323d2ac6b55938">curStaticInst</a> || !<a class="code" href="classBaseSimpleCPU.html#a8bfe7f75498271dfe7323d2ac6b55938">curStaticInst</a>-&gt;isDelayedCommit())
<a name="l00466"></a>00466             <a class="code" href="classBaseSimpleCPU.html#a3e4cbf8767e698f193906151e081bedd">checkForInterrupts</a>();
<a name="l00467"></a>00467 
<a name="l00468"></a>00468         <a class="code" href="classBaseSimpleCPU.html#a4b78450067adf34604e4059d614ce18a">checkPcEventQueue</a>();
<a name="l00469"></a>00469         <span class="comment">// We must have just got suspended by a PC event</span>
<a name="l00470"></a>00470         <span class="keywordflow">if</span> (<a class="code" href="classBaseSimpleCPU.html#a10a9927ef33b83d6cd4dbb90f2862181">_status</a> == <a class="code" href="classBaseSimpleCPU.html#a11b0e96158af07c6e2edfe028774238cafae0269c6164fdb111af106f09539323">Idle</a>) {
<a name="l00471"></a>00471             <a class="code" href="classAtomicSimpleCPU.html#a16e6c729b7f554c3bab3962407064371" title="Try to complete a drain request.">tryCompleteDrain</a>();
<a name="l00472"></a>00472             <span class="keywordflow">return</span>;
<a name="l00473"></a>00473         }
<a name="l00474"></a>00474 
<a name="l00475"></a>00475         <a class="code" href="classRefCountingPtr.html">Fault</a> fault = <a class="code" href="fault__fwd_8hh.html#ab8ce3b69a6737f63fcdcf99910feb153">NoFault</a>;
<a name="l00476"></a>00476 
<a name="l00477"></a>00477         <a class="code" href="namespaceAlphaISA.html#a233e755911c9143f96bef37eedb1e009">TheISA::PCState</a> <a class="code" href="classBaseSimpleCPU.html#a67965d274ad25d9ce3756fd15fbdaa15">pcState</a> = <a class="code" href="classBaseSimpleCPU.html#a3b1d88fd3d64c7475fed2adb94515f7d" title="SimpleThread object, provides all the architectural state.">thread</a>-&gt;<a class="code" href="classSimpleThread.html#aac01d6afdb95c2a68442b54255549c79">pcState</a>();
<a name="l00478"></a>00478 
<a name="l00479"></a>00479         <span class="keywordtype">bool</span> needToFetch = !<a class="code" href="base_2types_8hh.html#a01ec7071d9749218cc83949b3f93cd9b">isRomMicroPC</a>(pcState.microPC()) &amp;&amp;
<a name="l00480"></a>00480                            !<a class="code" href="classBaseSimpleCPU.html#a8af43f60ab6366f768575def72a813d0">curMacroStaticInst</a>;
<a name="l00481"></a>00481         <span class="keywordflow">if</span> (needToFetch) {
<a name="l00482"></a>00482             <a class="code" href="classBaseSimpleCPU.html#a9ec5f0ef84496e3679b1926f1c450e72">setupFetchRequest</a>(&amp;<a class="code" href="classAtomicSimpleCPU.html#ab1d4eecb4d4fad5a281b799a23dd315b">ifetch_req</a>);
<a name="l00483"></a>00483             fault = <a class="code" href="classBaseSimpleCPU.html#a3b1d88fd3d64c7475fed2adb94515f7d" title="SimpleThread object, provides all the architectural state.">thread</a>-&gt;<a class="code" href="classSimpleThread.html#adfa5cc84308f3d100f15662c5f19a319">itb</a>-&gt;translateAtomic(&amp;<a class="code" href="classAtomicSimpleCPU.html#ab1d4eecb4d4fad5a281b799a23dd315b">ifetch_req</a>, <a class="code" href="classBaseSimpleCPU.html#a1d94ea1eaa23dd214f48d3833601941d" title="ThreadContext object, provides an interface for external objects to modify this thread&amp;#39;s state...">tc</a>,
<a name="l00484"></a>00484                                                  <a class="code" href="classBaseTLB.html#a26b67ef35b9f92e337acf48571c7585ea63234010c6a55c971617a58bd577566b">BaseTLB::Execute</a>);
<a name="l00485"></a>00485         }
<a name="l00486"></a>00486 
<a name="l00487"></a>00487         <span class="keywordflow">if</span> (fault == <a class="code" href="fault__fwd_8hh.html#ab8ce3b69a6737f63fcdcf99910feb153">NoFault</a>) {
<a name="l00488"></a>00488             <a class="code" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643" title="Tick count type.">Tick</a> icache_latency = 0;
<a name="l00489"></a>00489             <span class="keywordtype">bool</span> icache_access = <span class="keyword">false</span>;
<a name="l00490"></a>00490             <a class="code" href="classAtomicSimpleCPU.html#a42f64c0d18992606b34c59a70c1fc9a6">dcache_access</a> = <span class="keyword">false</span>; <span class="comment">// assume no dcache access</span>
<a name="l00491"></a>00491 
<a name="l00492"></a>00492             <span class="keywordflow">if</span> (needToFetch) {
<a name="l00493"></a>00493                 <span class="comment">// This is commented out because the decoder would act like</span>
<a name="l00494"></a>00494                 <span class="comment">// a tiny cache otherwise. It wouldn&#39;t be flushed when needed</span>
<a name="l00495"></a>00495                 <span class="comment">// like the I cache. It should be flushed, and when that works</span>
<a name="l00496"></a>00496                 <span class="comment">// this code should be uncommented.</span>
<a name="l00497"></a>00497                 <span class="comment">//Fetch more instruction memory if necessary</span>
<a name="l00498"></a>00498                 <span class="comment">//if(decoder.needMoreBytes())</span>
<a name="l00499"></a>00499                 <span class="comment">//{</span>
<a name="l00500"></a>00500                     icache_access = <span class="keyword">true</span>;
<a name="l00501"></a>00501                     <a class="code" href="classPacket.html" title="A Packet is used to encapsulate a transfer between two objects in the memory system (e...">Packet</a> ifetch_pkt = <a class="code" href="classPacket.html" title="A Packet is used to encapsulate a transfer between two objects in the memory system (e...">Packet</a>(&amp;<a class="code" href="classAtomicSimpleCPU.html#ab1d4eecb4d4fad5a281b799a23dd315b">ifetch_req</a>, <a class="code" href="classMemCmd.html#ae5c39c2de0ad998b5176bc519b358102aa21449f51bc9023b2dc730a7cd2cbf16">MemCmd::ReadReq</a>);
<a name="l00502"></a>00502                     ifetch_pkt.<a class="code" href="classPacket.html#aa81ea5325a7aa403fa94f2d84f6f4236" title="Set the data pointer to the following value that should not be freed.">dataStatic</a>(&amp;<a class="code" href="classBaseSimpleCPU.html#a1fc11d911f6b8a1308324e86f81a9d24">inst</a>);
<a name="l00503"></a>00503 
<a name="l00504"></a>00504                     <span class="keywordflow">if</span> (<a class="code" href="classAtomicSimpleCPU.html#a2617122e0bc6eac8d5fb651d4c506f64">fastmem</a> &amp;&amp; <a class="code" href="classBaseCPU.html#aec7be52311ec347359ea6bffc40db74a">system</a>-&gt;<a class="code" href="classSystem.html#a59ccf6b92713bf241fbf6c9238db86a4" title="Check if a physical address is within a range of a memory that is part of the global address map...">isMemAddr</a>(ifetch_pkt.<a class="code" href="classPacket.html#a1c04785186ba5aa70a40cac9b2bfc86e">getAddr</a>()))
<a name="l00505"></a>00505                         <a class="code" href="classBaseCPU.html#aec7be52311ec347359ea6bffc40db74a">system</a>-&gt;<a class="code" href="classSystem.html#a1bcb5c7e0e5029f9c80bb747a0257d8a" title="Get a pointer to access the physical memory of the system.">getPhysMem</a>().<a class="code" href="classPhysicalMemory.html#a37b3796dfbc3dfd693675e79052b2deb" title="Perform an untimed memory access and update all the state (e.g.">access</a>(&amp;ifetch_pkt);
<a name="l00506"></a>00506                     <span class="keywordflow">else</span>
<a name="l00507"></a>00507                         icache_latency = <a class="code" href="classAtomicSimpleCPU.html#aa8a2cde648e8f9343a32795bcba5d65f">icachePort</a>.sendAtomic(&amp;ifetch_pkt);
<a name="l00508"></a>00508 
<a name="l00509"></a>00509                     assert(!ifetch_pkt.<a class="code" href="classPacket.html#a1ea5391da77928d157f79bebe80f6a97">isError</a>());
<a name="l00510"></a>00510 
<a name="l00511"></a>00511                     <span class="comment">// ifetch_req is initialized to read the instruction directly</span>
<a name="l00512"></a>00512                     <span class="comment">// into the CPU object&#39;s inst field.</span>
<a name="l00513"></a>00513                 <span class="comment">//}</span>
<a name="l00514"></a>00514             }
<a name="l00515"></a>00515 
<a name="l00516"></a>00516             <a class="code" href="classBaseSimpleCPU.html#afd61f01f4e1ffb85eff494734ce68e88">preExecute</a>();
<a name="l00517"></a>00517 
<a name="l00518"></a>00518             <span class="keywordflow">if</span> (<a class="code" href="classBaseSimpleCPU.html#a8bfe7f75498271dfe7323d2ac6b55938">curStaticInst</a>) {
<a name="l00519"></a>00519                 fault = <a class="code" href="classBaseSimpleCPU.html#a8bfe7f75498271dfe7323d2ac6b55938">curStaticInst</a>-&gt;execute(<span class="keyword">this</span>, <a class="code" href="classBaseSimpleCPU.html#a1c5b42da4bb058bf584c14d4efe4e456">traceData</a>);
<a name="l00520"></a>00520 
<a name="l00521"></a>00521                 <span class="comment">// keep an instruction count</span>
<a name="l00522"></a>00522                 <span class="keywordflow">if</span> (fault == <a class="code" href="fault__fwd_8hh.html#ab8ce3b69a6737f63fcdcf99910feb153">NoFault</a>)
<a name="l00523"></a>00523                     <a class="code" href="classBaseSimpleCPU.html#a2c520e5668a379e4c7dc05cc03127001">countInst</a>();
<a name="l00524"></a>00524                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="classBaseSimpleCPU.html#a1c5b42da4bb058bf584c14d4efe4e456">traceData</a> &amp;&amp; !<a class="code" href="trace_8hh.html#af76c9f7776aade1bf9d7dfa8a0c6b341">DTRACE</a>(ExecFaulting)) {
<a name="l00525"></a>00525                     <span class="keyword">delete</span> <a class="code" href="classBaseSimpleCPU.html#a1c5b42da4bb058bf584c14d4efe4e456">traceData</a>;
<a name="l00526"></a>00526                     <a class="code" href="classBaseSimpleCPU.html#a1c5b42da4bb058bf584c14d4efe4e456">traceData</a> = NULL;
<a name="l00527"></a>00527                 }
<a name="l00528"></a>00528 
<a name="l00529"></a>00529                 <a class="code" href="classBaseSimpleCPU.html#a59264184faf4bf78d00099b624183107">postExecute</a>();
<a name="l00530"></a>00530             }
<a name="l00531"></a>00531 
<a name="l00532"></a>00532             <span class="comment">// @todo remove me after debugging with legion done</span>
<a name="l00533"></a>00533             <span class="keywordflow">if</span> (<a class="code" href="classBaseSimpleCPU.html#a8bfe7f75498271dfe7323d2ac6b55938">curStaticInst</a> &amp;&amp; (!<a class="code" href="classBaseSimpleCPU.html#a8bfe7f75498271dfe7323d2ac6b55938">curStaticInst</a>-&gt;isMicroop() ||
<a name="l00534"></a>00534                         <a class="code" href="classBaseSimpleCPU.html#a8bfe7f75498271dfe7323d2ac6b55938">curStaticInst</a>-&gt;isFirstMicroop()))
<a name="l00535"></a>00535                 <a class="code" href="classBaseCPU.html#a1e3fa77b4ef4cf21fbfb193ec94e9154">instCnt</a>++;
<a name="l00536"></a>00536 
<a name="l00537"></a>00537             <a class="code" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643" title="Tick count type.">Tick</a> stall_ticks = 0;
<a name="l00538"></a>00538             <span class="keywordflow">if</span> (<a class="code" href="classAtomicSimpleCPU.html#a95cf1c3c3394043b095a96474e4b02b6">simulate_inst_stalls</a> &amp;&amp; icache_access)
<a name="l00539"></a>00539                 stall_ticks += icache_latency;
<a name="l00540"></a>00540 
<a name="l00541"></a>00541             <span class="keywordflow">if</span> (<a class="code" href="classAtomicSimpleCPU.html#a94a9cd780dfc57a462b5bbea1ec9943e">simulate_data_stalls</a> &amp;&amp; <a class="code" href="classAtomicSimpleCPU.html#a42f64c0d18992606b34c59a70c1fc9a6">dcache_access</a>)
<a name="l00542"></a>00542                 stall_ticks += <a class="code" href="classAtomicSimpleCPU.html#a547478889037038166417a298d5cf430">dcache_latency</a>;
<a name="l00543"></a>00543 
<a name="l00544"></a>00544             <span class="keywordflow">if</span> (stall_ticks) {
<a name="l00545"></a>00545                 <span class="comment">// the atomic cpu does its accounting in ticks, so</span>
<a name="l00546"></a>00546                 <span class="comment">// keep counting in ticks but round to the clock</span>
<a name="l00547"></a>00547                 <span class="comment">// period</span>
<a name="l00548"></a>00548                 latency += <a class="code" href="intmath_8hh.html#ae842b412d3570df97a944085b8f85850">divCeil</a>(stall_ticks, <a class="code" href="classClockedObject.html#a3f0850d695e3722cdd7d33bbaf3e5f43">clockPeriod</a>()) *
<a name="l00549"></a>00549                     <a class="code" href="classClockedObject.html#a3f0850d695e3722cdd7d33bbaf3e5f43">clockPeriod</a>();
<a name="l00550"></a>00550             }
<a name="l00551"></a>00551 
<a name="l00552"></a>00552         }
<a name="l00553"></a>00553         <span class="keywordflow">if</span>(fault != <a class="code" href="fault__fwd_8hh.html#ab8ce3b69a6737f63fcdcf99910feb153">NoFault</a> || !<a class="code" href="classBaseSimpleCPU.html#a15483d2869b46930a1e62ae733a1b45f">stayAtPC</a>)
<a name="l00554"></a>00554             <a class="code" href="classBaseSimpleCPU.html#a1ca7acb41e96d7e1b851326fc5494afd">advancePC</a>(fault);
<a name="l00555"></a>00555     }
<a name="l00556"></a>00556 
<a name="l00557"></a>00557     <span class="keywordflow">if</span> (<a class="code" href="classAtomicSimpleCPU.html#a16e6c729b7f554c3bab3962407064371" title="Try to complete a drain request.">tryCompleteDrain</a>())
<a name="l00558"></a>00558         <span class="keywordflow">return</span>;
<a name="l00559"></a>00559 
<a name="l00560"></a>00560     <span class="comment">// instruction takes at least one cycle</span>
<a name="l00561"></a>00561     <span class="keywordflow">if</span> (latency &lt; <a class="code" href="classClockedObject.html#a3f0850d695e3722cdd7d33bbaf3e5f43">clockPeriod</a>())
<a name="l00562"></a>00562         latency = <a class="code" href="classClockedObject.html#a3f0850d695e3722cdd7d33bbaf3e5f43">clockPeriod</a>();
<a name="l00563"></a>00563 
<a name="l00564"></a>00564     <span class="keywordflow">if</span> (<a class="code" href="classBaseSimpleCPU.html#a10a9927ef33b83d6cd4dbb90f2862181">_status</a> != <a class="code" href="classBaseSimpleCPU.html#a11b0e96158af07c6e2edfe028774238cafae0269c6164fdb111af106f09539323">Idle</a>)
<a name="l00565"></a>00565         <a class="code" href="classEventManager.html#a749a10828b2dd5017a2582960d04e400">schedule</a>(<a class="code" href="classAtomicSimpleCPU.html#a77b35d6b2a4345c6d3971fc64a4d9342">tickEvent</a>, <a class="code" href="statistics_8hh.html#a7acdccbf0d35ce0c159c0cdd36371b22" title="The current simulated tick.">curTick</a>() + latency);
<a name="l00566"></a>00566 }
<a name="l00567"></a>00567 
<a name="l00568"></a>00568 
<a name="l00569"></a>00569 <span class="keywordtype">void</span>
<a name="l00570"></a><a class="code" href="classAtomicSimpleCPU.html#a4bdf2f0b245ffd0568b9db9d3c006720">00570</a> <a class="code" href="classAtomicSimpleCPU.html#a4bdf2f0b245ffd0568b9db9d3c006720" title="Print state of address in memory system via PrintReq (for debugging).">AtomicSimpleCPU::printAddr</a>(<a class="code" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232" title="Address type This will probably be moved somewhere else in the near future.">Addr</a> <a class="code" href="namespaceArmISA.html#a6f0a7b59bfa9544f3d21fb56433497cc">a</a>)
<a name="l00571"></a>00571 {
<a name="l00572"></a>00572     <a class="code" href="classAtomicSimpleCPU.html#a40e95ebf12757f1685fee06d33452260">dcachePort</a>.printAddr(a);
<a name="l00573"></a>00573 }
<a name="l00574"></a>00574 
<a name="l00575"></a>00575 
<a name="l00577"></a>00577 <span class="comment">//</span>
<a name="l00578"></a>00578 <span class="comment">//  AtomicSimpleCPU Simulation Object</span>
<a name="l00579"></a>00579 <span class="comment">//</span>
<a name="l00580"></a>00580 <a class="code" href="classAtomicSimpleCPU.html">AtomicSimpleCPU</a> *
<a name="l00581"></a>00581 AtomicSimpleCPUParams::create()
<a name="l00582"></a>00582 {
<a name="l00583"></a>00583     <a class="code" href="classBaseCPU.html#a7c1d0eec4075862b04e96cad7a82799d" title="Number of threads we&amp;#39;re actually simulating (&amp;lt;= SMT_MAX_THREADS).">numThreads</a> = 1;
<a name="l00584"></a>00584     <span class="keywordflow">if</span> (!<a class="code" href="full__system_8hh.html#af929576af6f85c8849704b66d04b8370" title="The FullSystem variable can be used to determine the current mode of simulation.">FullSystem</a> &amp;&amp; workload.size() != 1)
<a name="l00585"></a>00585         <a class="code" href="base_2misc_8hh.html#a1445e207e36c97ff84c54b47288cea19">panic</a>(<span class="stringliteral">&quot;only one workload allowed&quot;</span>);
<a name="l00586"></a>00586     <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="classAtomicSimpleCPU.html#a7316bea4bcc46803a8665d2b60c56cc3">AtomicSimpleCPU</a>(<span class="keyword">this</span>);
<a name="l00587"></a>00587 }
</pre></div></div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&nbsp;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1"><address style="align: right;"><small>
Generated on Sun Apr 7 2013 18:16:28 for gem5 by <a href="http://www.doxygen.org/index.html"> doxygen</a> 1.7.1</small></address>

</body>
</html>
