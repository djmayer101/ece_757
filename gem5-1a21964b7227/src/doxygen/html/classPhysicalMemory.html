<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>gem5: PhysicalMemory Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a>  </div>
  <div class="headertitle">
<h1>PhysicalMemory Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="PhysicalMemory" --><!-- doxytag: inherits="Serializable" -->
<p>The physical memory encapsulates all memories in the system and provides basic functionality for accessing those memories without going through the memory system and interconnect.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="physical_8hh_source.html">physical.hh</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for PhysicalMemory:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classPhysicalMemory.png" usemap="#PhysicalMemory_map" alt=""/>
  <map id="PhysicalMemory_map" name="PhysicalMemory_map">
<area href="classSerializable.html" alt="Serializable" shape="rect" coords="0,0,106,24"/>
</map>
</div>

<p><a href="classPhysicalMemory-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPhysicalMemory.html#ae9405616cacd3b59442e20621d747f23">PhysicalMemory</a> (const std::string &amp;<a class="el" href="classPhysicalMemory.html#ab350c0762d0512becaba3ef121cec592">_name</a>, const <a class="el" href="classstd_1_1vector.html">std::vector</a>&lt; <a class="el" href="classAbstractMemory.html">AbstractMemory</a> * &gt; &amp;_memories)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a physical memory object, wrapping a number of memories.  <a href="#ae9405616cacd3b59442e20621d747f23"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPhysicalMemory.html#a72332a339430d947462769976c1ab1f2">~PhysicalMemory</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unmap all the backing store we have used.  <a href="#a72332a339430d947462769976c1ab1f2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPhysicalMemory.html#a941059c699fc6ff72dea60f73e4f9056">name</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the name for debugging and for creation of sections for checkpointing.  <a href="#a941059c699fc6ff72dea60f73e4f9056"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPhysicalMemory.html#a8e16055f1b05dca450839000810e7348">isMemAddr</a> (<a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a> addr) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classCheck.html">Check</a> if a physical address is within a range of a memory that is part of the global address map.  <a href="#a8e16055f1b05dca450839000810e7348"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstd_1_1list.html">AddrRangeList</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPhysicalMemory.html#a760ca8af7587cb29ee3fe6a5abc2f350">getConfAddrRanges</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the memory ranges for all memories that are to be reported to the configuration table.  <a href="#a760ca8af7587cb29ee3fe6a5abc2f350"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPhysicalMemory.html#a3fa1330f3e70f3c90eaa38ee46e5427c">totalSize</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the total physical memory size.  <a href="#a3fa1330f3e70f3c90eaa38ee46e5427c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstd_1_1vector.html">std::vector</a>&lt; <a class="el" href="classstd_1_1pair.html">std::pair</a><br class="typebreak"/>
&lt; <a class="el" href="classAddrRange.html">AddrRange</a>, uint8_t * &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPhysicalMemory.html#ab48f15575226efb93b111407ed6a220c">getBackingStore</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the pointers to the backing store for external host access.  <a href="#ab48f15575226efb93b111407ed6a220c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPhysicalMemory.html#a37b3796dfbc3dfd693675e79052b2deb">access</a> (<a class="el" href="classPacket.html">PacketPtr</a> pkt)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Perform an untimed memory access and update all the state (e.g.  <a href="#a37b3796dfbc3dfd693675e79052b2deb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPhysicalMemory.html#a2d828f36824d5593511c79fe716e484c">functionalAccess</a> (<a class="el" href="classPacket.html">PacketPtr</a> pkt)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Perform an untimed memory read or write without changing anything but the memory itself.  <a href="#a2d828f36824d5593511c79fe716e484c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPhysicalMemory.html#a572548ace5d3539b8d0188b7a02eb886">serialize</a> (std::ostream &amp;os)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Serialize all the memories in the system.  <a href="#a572548ace5d3539b8d0188b7a02eb886"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPhysicalMemory.html#a52a0246b7f799b580a729cd61bc51fc1">serializeStore</a> (std::ostream &amp;os, unsigned int store_id, <a class="el" href="classAddrRange.html">AddrRange</a> range, uint8_t *pmem)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Serialize a specific store.  <a href="#a52a0246b7f799b580a729cd61bc51fc1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPhysicalMemory.html#ac3840a0189ac8cdbcf82aee64add36d5">unserialize</a> (<a class="el" href="classCheckpoint.html">Checkpoint</a> *cp, const std::string &amp;section)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unserialize the memories in the system.  <a href="#ac3840a0189ac8cdbcf82aee64add36d5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPhysicalMemory.html#ae2f72deecd3e11021bc2fd7b9c989d2d">unserializeStore</a> (<a class="el" href="classCheckpoint.html">Checkpoint</a> *cp, const std::string &amp;section)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unserialize a specific backing store, identified by a section.  <a href="#ae2f72deecd3e11021bc2fd7b9c989d2d"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPhysicalMemory.html#aef8c3120060f8bec78007da8e9210090">PhysicalMemory</a> (const <a class="el" href="classPhysicalMemory.html">PhysicalMemory</a> &amp;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPhysicalMemory.html">PhysicalMemory</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPhysicalMemory.html#a71c8726f1fb049dcb4c219e474158589">operator=</a> (const <a class="el" href="classPhysicalMemory.html">PhysicalMemory</a> &amp;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPhysicalMemory.html#afb789930304901ae8e043f19756b503a">createBackingStore</a> (<a class="el" href="classAddrRange.html">AddrRange</a> range, const <a class="el" href="classstd_1_1vector.html">std::vector</a>&lt; <a class="el" href="classAbstractMemory.html">AbstractMemory</a> * &gt; &amp;_memories)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create the memory region providing the backing store for a given address range that corresponds to a set of memories in the simulated system.  <a href="#afb789930304901ae8e043f19756b503a"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPhysicalMemory.html#ab350c0762d0512becaba3ef121cec592">_name</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAddrRangeMap.html">AddrRangeMap</a>&lt; <a class="el" href="classAbstractMemory.html">AbstractMemory</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPhysicalMemory.html#ad32160a7be31ecb6f7564f35c950923a">addrMap</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAddrRange.html">AddrRange</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPhysicalMemory.html#a3126543dde80e39f62c0226fb527f9d9">rangeCache</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstd_1_1vector.html">std::vector</a>&lt; <a class="el" href="classAbstractMemory.html">AbstractMemory</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPhysicalMemory.html#aa871234aa6c34d601d7382243285a4e2">memories</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPhysicalMemory.html#a5593123b31f52c14675a125076fca73e">size</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstd_1_1vector.html">std::vector</a>&lt; <a class="el" href="classstd_1_1pair.html">std::pair</a><br class="typebreak"/>
&lt; <a class="el" href="classAddrRange.html">AddrRange</a>, uint8_t * &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPhysicalMemory.html#a554f1a3b7055f66bcfce9a55d629f94b">backingStore</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>The physical memory encapsulates all memories in the system and provides basic functionality for accessing those memories without going through the memory system and interconnect. </p>
<p>The physical memory is also responsible for providing the host system backingstore used by the memories in the simulated guest system. When the system is created, the physical memory allocates the backing store based on the address ranges that are populated in the system, and does so indepentent of how those map to actual memory controllers. Thus, the physical memory completely abstracts the mapping of the backing store of the host system and the address mapping in the guest system. This enables us to arbitrarily change the number of memory controllers, and their address mapping, as long as the ranges stay the same. </p>

<p>Definition at line <a class="el" href="physical_8hh_source.html#l00067">67</a> of file <a class="el" href="physical_8hh_source.html">physical.hh</a>.</p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="aef8c3120060f8bec78007da8e9210090"></a><!-- doxytag: member="PhysicalMemory::PhysicalMemory" ref="aef8c3120060f8bec78007da8e9210090" args="(const PhysicalMemory &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PhysicalMemory::PhysicalMemory </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPhysicalMemory.html">PhysicalMemory</a> &amp;&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ae9405616cacd3b59442e20621d747f23"></a><!-- doxytag: member="PhysicalMemory::PhysicalMemory" ref="ae9405616cacd3b59442e20621d747f23" args="(const std::string &amp;_name, const std::vector&lt; AbstractMemory * &gt; &amp;_memories)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PhysicalMemory::PhysicalMemory </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstd_1_1vector.html">std::vector</a>&lt; <a class="el" href="classAbstractMemory.html">AbstractMemory</a> * &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>_memories</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a physical memory object, wrapping a number of memories. </p>

</div>
</div>
<a class="anchor" id="a72332a339430d947462769976c1ab1f2"></a><!-- doxytag: member="PhysicalMemory::~PhysicalMemory" ref="a72332a339430d947462769976c1ab1f2" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PhysicalMemory::~PhysicalMemory </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unmap all the backing store we have used. </p>

<p>Definition at line <a class="el" href="physical_8cc_source.html#l00192">192</a> of file <a class="el" href="physical_8cc_source.html">physical.cc</a>.</p>

<p>References <a class="el" href="physical_8hh_source.html#l00089">backingStore</a>, and <a class="el" href="dt__constants_8hh_source.html#l00081">MipsISA::s</a>.</p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a37b3796dfbc3dfd693675e79052b2deb"></a><!-- doxytag: member="PhysicalMemory::access" ref="a37b3796dfbc3dfd693675e79052b2deb" args="(PacketPtr pkt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PhysicalMemory::access </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPacket.html">PacketPtr</a>&nbsp;</td>
          <td class="paramname"> <em>pkt</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Perform an untimed memory access and update all the state (e.g. </p>
<p>locked addresses) and statistics accordingly. The packet is turned into a response if required.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pkt</em>&nbsp;</td><td><a class="el" href="classPacket.html" title="A Packet is used to encapsulate a transfer between two objects in the memory system (e...">Packet</a> performing the access </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="physical_8cc_source.html#l00259">259</a> of file <a class="el" href="physical_8cc_source.html">physical.cc</a>.</p>

<p>References <a class="el" href="arch_2x86_2types_8hh_source.html#l00079">X86ISA::addr</a>, <a class="el" href="physical_8hh_source.html#l00076">addrMap</a>, <a class="el" href="addr__range__map_8hh_source.html#l00163">AddrRangeMap&lt; V &gt;::end()</a>, <a class="el" href="addr__range__map_8hh_source.html#l00069">AddrRangeMap&lt; V &gt;::find()</a>, <a class="el" href="packet_8hh_source.html#l00552">Packet::getAddr()</a>, <a class="el" href="packet_8hh_source.html#l00496">Packet::isRequest()</a>, and <a class="el" href="arm_2miscregs_8hh_source.html#l00378">ArmISA::m</a>.</p>

<p>Referenced by <a class="el" href="RubyPort_8cc_source.html#l00416">RubyPort::M5Port::hitCallback()</a>, <a class="el" href="atomic_8cc_source.html#l00265">AtomicSimpleCPU::readMem()</a>, <a class="el" href="atomic_8cc_source.html#l00456">AtomicSimpleCPU::tick()</a>, and <a class="el" href="atomic_8cc_source.html#l00353">AtomicSimpleCPU::writeMem()</a>.</p>

</div>
</div>
<a class="anchor" id="afb789930304901ae8e043f19756b503a"></a><!-- doxytag: member="PhysicalMemory::createBackingStore" ref="afb789930304901ae8e043f19756b503a" args="(AddrRange range, const std::vector&lt; AbstractMemory * &gt; &amp;_memories)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PhysicalMemory::createBackingStore </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAddrRange.html">AddrRange</a>&nbsp;</td>
          <td class="paramname"> <em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstd_1_1vector.html">std::vector</a>&lt; <a class="el" href="classAbstractMemory.html">AbstractMemory</a> * &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>_memories</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create the memory region providing the backing store for a given address range that corresponds to a set of memories in the simulated system. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>range</em>&nbsp;</td><td>The address range covered </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>memories</em>&nbsp;</td><td>The memories this range maps to </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="physical_8cc_source.html#l00140">140</a> of file <a class="el" href="physical_8cc_source.html">physical.cc</a>.</p>

<p>References <a class="el" href="physical_8hh_source.html#l00089">backingStore</a>, <a class="el" href="trace_8hh_source.html#l00129">DPRINTF</a>, <a class="el" href="base_2misc_8hh_source.html#l00084">fatal</a>, <a class="el" href="addr__range_8hh_source.html#l00136">AddrRange::interleaved()</a>, <a class="el" href="arm_2miscregs_8hh_source.html#l00378">ArmISA::m</a>, <a class="el" href="base_2misc_8hh_source.html#l00074">panic</a>, <a class="el" href="addr__range_8hh_source.html#l00161">AddrRange::size()</a>, and <a class="el" href="addr__range_8hh_source.html#l00181">AddrRange::to_string()</a>.</p>

</div>
</div>
<a class="anchor" id="a2d828f36824d5593511c79fe716e484c"></a><!-- doxytag: member="PhysicalMemory::functionalAccess" ref="a2d828f36824d5593511c79fe716e484c" args="(PacketPtr pkt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PhysicalMemory::functionalAccess </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPacket.html">PacketPtr</a>&nbsp;</td>
          <td class="paramname"> <em>pkt</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Perform an untimed memory read or write without changing anything but the memory itself. </p>
<p>No stats are affected by this access. In addition to normal accesses this also facilitates print requests.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pkt</em>&nbsp;</td><td><a class="el" href="classPacket.html" title="A Packet is used to encapsulate a transfer between two objects in the memory system (e...">Packet</a> performing the access </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="physical_8cc_source.html#l00269">269</a> of file <a class="el" href="physical_8cc_source.html">physical.cc</a>.</p>

<p>References <a class="el" href="arch_2x86_2types_8hh_source.html#l00079">X86ISA::addr</a>, <a class="el" href="physical_8hh_source.html#l00076">addrMap</a>, <a class="el" href="addr__range__map_8hh_source.html#l00163">AddrRangeMap&lt; V &gt;::end()</a>, <a class="el" href="addr__range__map_8hh_source.html#l00069">AddrRangeMap&lt; V &gt;::find()</a>, <a class="el" href="packet_8hh_source.html#l00552">Packet::getAddr()</a>, <a class="el" href="packet_8hh_source.html#l00496">Packet::isRequest()</a>, and <a class="el" href="arm_2miscregs_8hh_source.html#l00378">ArmISA::m</a>.</p>

<p>Referenced by <a class="el" href="RubyPort_8cc_source.html#l00235">RubyPort::M5Port::recvFunctional()</a>.</p>

</div>
</div>
<a class="anchor" id="ab48f15575226efb93b111407ed6a220c"></a><!-- doxytag: member="PhysicalMemory::getBackingStore" ref="ab48f15575226efb93b111407ed6a220c" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstd_1_1vector.html">std::vector</a>&lt;<a class="el" href="classstd_1_1pair.html">std::pair</a>&lt;<a class="el" href="classAddrRange.html">AddrRange</a>, uint8_t*&gt; &gt; PhysicalMemory::getBackingStore </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the pointers to the backing store for external host access. </p>
<p>Note that memory in the guest should be accessed using <a class="el" href="classPhysicalMemory.html#a37b3796dfbc3dfd693675e79052b2deb" title="Perform an untimed memory access and update all the state (e.g.">access()</a> or <a class="el" href="classPhysicalMemory.html#a2d828f36824d5593511c79fe716e484c" title="Perform an untimed memory read or write without changing anything but the memory itself.">functionalAccess()</a>. This interface is primarily intended for CPU models using hardware virtualization. Note that memories that are null are not present, and that the backing store may also contain memories that are not part of the OS-visible global address map and thus are allowed to overlap.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Pointers to the memory backing store </dd></dl>

<p>Definition at line <a class="el" href="physical_8hh_source.html#l00165">165</a> of file <a class="el" href="physical_8hh_source.html">physical.hh</a>.</p>

<p>References <a class="el" href="physical_8hh_source.html#l00089">backingStore</a>.</p>

</div>
</div>
<a class="anchor" id="a760ca8af7587cb29ee3fe6a5abc2f350"></a><!-- doxytag: member="PhysicalMemory::getConfAddrRanges" ref="a760ca8af7587cb29ee3fe6a5abc2f350" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstd_1_1list.html">AddrRangeList</a> PhysicalMemory::getConfAddrRanges </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the memory ranges for all memories that are to be reported to the configuration table. </p>
<p>The ranges are merged before they are returned such that any interleaved ranges appear as a single range.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>All configuration table memory ranges </dd></dl>

<p>Definition at line <a class="el" href="physical_8cc_source.html#l00222">222</a> of file <a class="el" href="physical_8cc_source.html">physical.cc</a>.</p>

<p>References <a class="el" href="physical_8hh_source.html#l00076">addrMap</a>, <a class="el" href="addr__range__map_8hh_source.html#l00151">AddrRangeMap&lt; V &gt;::begin()</a>, <a class="el" href="addr__range__map_8hh_source.html#l00163">AddrRangeMap&lt; V &gt;::end()</a>, and <a class="el" href="pra__constants_8hh_source.html#l00097">MipsISA::r</a>.</p>

<p>Referenced by <a class="el" href="arch_2arm_2linux_2system_8cc_source.html#l00114">LinuxArmSystem::initState()</a>.</p>

</div>
</div>
<a class="anchor" id="a8e16055f1b05dca450839000810e7348"></a><!-- doxytag: member="PhysicalMemory::isMemAddr" ref="a8e16055f1b05dca450839000810e7348" args="(Addr addr) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PhysicalMemory::isMemAddr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a>&nbsp;</td>
          <td class="paramname"> <em>addr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="classCheck.html">Check</a> if a physical address is within a range of a memory that is part of the global address map. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>addr</em>&nbsp;</td><td>A physical address </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Whether the address corresponds to a memory </dd></dl>

<p>Definition at line <a class="el" href="physical_8cc_source.html#l00201">201</a> of file <a class="el" href="physical_8cc_source.html">physical.cc</a>.</p>

<p>References <a class="el" href="physical_8hh_source.html#l00076">addrMap</a>, <a class="el" href="addr__range_8hh_source.html#l00259">AddrRange::contains()</a>, <a class="el" href="addr__range__map_8hh_source.html#l00163">AddrRangeMap&lt; V &gt;::end()</a>, <a class="el" href="addr__range__map_8hh_source.html#l00069">AddrRangeMap&lt; V &gt;::find()</a>, <a class="el" href="pra__constants_8hh_source.html#l00097">MipsISA::r</a>, and <a class="el" href="physical_8hh_source.html#l00079">rangeCache</a>.</p>

<p>Referenced by <a class="el" href="sim_2system_8cc_source.html#l00326">System::isMemAddr()</a>.</p>

</div>
</div>
<a class="anchor" id="a941059c699fc6ff72dea60f73e4f9056"></a><!-- doxytag: member="PhysicalMemory::name" ref="a941059c699fc6ff72dea60f73e4f9056" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string PhysicalMemory::name </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the name for debugging and for creation of sections for checkpointing. </p>

<p>Implements <a class="el" href="classSerializable.html#a970f537b2f01c6653e92f2dc7a1a4b4d">Serializable</a>.</p>

<p>Definition at line <a class="el" href="physical_8hh_source.html#l00125">125</a> of file <a class="el" href="physical_8hh_source.html">physical.hh</a>.</p>

<p>References <a class="el" href="physical_8hh_source.html#l00073">_name</a>.</p>

</div>
</div>
<a class="anchor" id="a71c8726f1fb049dcb4c219e474158589"></a><!-- doxytag: member="PhysicalMemory::operator=" ref="a71c8726f1fb049dcb4c219e474158589" args="(const PhysicalMemory &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPhysicalMemory.html">PhysicalMemory</a>&amp; PhysicalMemory::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPhysicalMemory.html">PhysicalMemory</a> &amp;&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a572548ace5d3539b8d0188b7a02eb886"></a><!-- doxytag: member="PhysicalMemory::serialize" ref="a572548ace5d3539b8d0188b7a02eb886" args="(std::ostream &amp;os)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PhysicalMemory::serialize </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>os</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Serialize all the memories in the system. </p>
<p>This is independent of the logical memory layout, and the serialization only sees the contigous backing store, independent of how this maps to logical memories in the guest system.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>os</em>&nbsp;</td><td>stream to serialize to </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classSerializable.html#af4c845a584ff629b4428a1ed02a586f5">Serializable</a>.</p>

</div>
</div>
<a class="anchor" id="a52a0246b7f799b580a729cd61bc51fc1"></a><!-- doxytag: member="PhysicalMemory::serializeStore" ref="a52a0246b7f799b580a729cd61bc51fc1" args="(std::ostream &amp;os, unsigned int store_id, AddrRange range, uint8_t *pmem)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PhysicalMemory::serializeStore </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>store_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAddrRange.html">AddrRange</a>&nbsp;</td>
          <td class="paramname"> <em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&nbsp;</td>
          <td class="paramname"> <em>pmem</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Serialize a specific store. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>store_id</em>&nbsp;</td><td>Unique identifier of this backing store </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>range</em>&nbsp;</td><td>The address range of this backing store </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pmem</em>&nbsp;</td><td>The host pointer to this backing store </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3fa1330f3e70f3c90eaa38ee46e5427c"></a><!-- doxytag: member="PhysicalMemory::totalSize" ref="a3fa1330f3e70f3c90eaa38ee46e5427c" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t PhysicalMemory::totalSize </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the total physical memory size. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The sum of all memory sizes </dd></dl>

<p>Definition at line <a class="el" href="physical_8hh_source.html#l00151">151</a> of file <a class="el" href="physical_8hh_source.html">physical.hh</a>.</p>

<p>References <a class="el" href="physical_8hh_source.html#l00085">size</a>.</p>

<p>Referenced by <a class="el" href="sim_2system_8cc_source.html#l00304">System::allocPhysPages()</a>, <a class="el" href="sim_2system_8cc_source.html#l00320">System::freeMemSize()</a>, and <a class="el" href="sim_2system_8cc_source.html#l00314">System::memSize()</a>.</p>

</div>
</div>
<a class="anchor" id="ac3840a0189ac8cdbcf82aee64add36d5"></a><!-- doxytag: member="PhysicalMemory::unserialize" ref="ac3840a0189ac8cdbcf82aee64add36d5" args="(Checkpoint *cp, const std::string &amp;section)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PhysicalMemory::unserialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCheckpoint.html">Checkpoint</a> *&nbsp;</td>
          <td class="paramname"> <em>cp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>section</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unserialize the memories in the system. </p>
<p>As with the serialization, this action is independent of how the address ranges are mapped to logical memories in the guest system. </p>

<p>Reimplemented from <a class="el" href="classSerializable.html#a5e83c7a6c6266d4e365f6ec7cb949caf">Serializable</a>.</p>

</div>
</div>
<a class="anchor" id="ae2f72deecd3e11021bc2fd7b9c989d2d"></a><!-- doxytag: member="PhysicalMemory::unserializeStore" ref="ae2f72deecd3e11021bc2fd7b9c989d2d" args="(Checkpoint *cp, const std::string &amp;section)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PhysicalMemory::unserializeStore </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCheckpoint.html">Checkpoint</a> *&nbsp;</td>
          <td class="paramname"> <em>cp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>section</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unserialize a specific backing store, identified by a section. </p>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="ab350c0762d0512becaba3ef121cec592"></a><!-- doxytag: member="PhysicalMemory::_name" ref="ab350c0762d0512becaba3ef121cec592" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classPhysicalMemory.html#ab350c0762d0512becaba3ef121cec592">PhysicalMemory::_name</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="physical_8hh_source.html#l00073">73</a> of file <a class="el" href="physical_8hh_source.html">physical.hh</a>.</p>

<p>Referenced by <a class="el" href="physical_8hh_source.html#l00125">name()</a>.</p>

</div>
</div>
<a class="anchor" id="ad32160a7be31ecb6f7564f35c950923a"></a><!-- doxytag: member="PhysicalMemory::addrMap" ref="ad32160a7be31ecb6f7564f35c950923a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAddrRangeMap.html">AddrRangeMap</a>&lt;<a class="el" href="classAbstractMemory.html">AbstractMemory</a>*&gt; <a class="el" href="classPhysicalMemory.html#ad32160a7be31ecb6f7564f35c950923a">PhysicalMemory::addrMap</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="physical_8hh_source.html#l00076">76</a> of file <a class="el" href="physical_8hh_source.html">physical.hh</a>.</p>

<p>Referenced by <a class="el" href="physical_8cc_source.html#l00259">access()</a>, <a class="el" href="physical_8cc_source.html#l00269">functionalAccess()</a>, <a class="el" href="physical_8cc_source.html#l00222">getConfAddrRanges()</a>, and <a class="el" href="physical_8cc_source.html#l00201">isMemAddr()</a>.</p>

</div>
</div>
<a class="anchor" id="a554f1a3b7055f66bcfce9a55d629f94b"></a><!-- doxytag: member="PhysicalMemory::backingStore" ref="a554f1a3b7055f66bcfce9a55d629f94b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstd_1_1vector.html">std::vector</a>&lt;<a class="el" href="classstd_1_1pair.html">std::pair</a>&lt;<a class="el" href="classAddrRange.html">AddrRange</a>, uint8_t*&gt; &gt; <a class="el" href="classPhysicalMemory.html#a554f1a3b7055f66bcfce9a55d629f94b">PhysicalMemory::backingStore</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="physical_8hh_source.html#l00089">89</a> of file <a class="el" href="physical_8hh_source.html">physical.hh</a>.</p>

<p>Referenced by <a class="el" href="physical_8cc_source.html#l00140">createBackingStore()</a>, <a class="el" href="physical_8hh_source.html#l00165">getBackingStore()</a>, and <a class="el" href="physical_8cc_source.html#l00192">~PhysicalMemory()</a>.</p>

</div>
</div>
<a class="anchor" id="aa871234aa6c34d601d7382243285a4e2"></a><!-- doxytag: member="PhysicalMemory::memories" ref="aa871234aa6c34d601d7382243285a4e2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstd_1_1vector.html">std::vector</a>&lt;<a class="el" href="classAbstractMemory.html">AbstractMemory</a>*&gt; <a class="el" href="classPhysicalMemory.html#aa871234aa6c34d601d7382243285a4e2">PhysicalMemory::memories</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="physical_8hh_source.html#l00082">82</a> of file <a class="el" href="physical_8hh_source.html">physical.hh</a>.</p>

</div>
</div>
<a class="anchor" id="a3126543dde80e39f62c0226fb527f9d9"></a><!-- doxytag: member="PhysicalMemory::rangeCache" ref="a3126543dde80e39f62c0226fb527f9d9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAddrRange.html">AddrRange</a> <a class="el" href="classPhysicalMemory.html#a3126543dde80e39f62c0226fb527f9d9">PhysicalMemory::rangeCache</a><code> [mutable, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="physical_8hh_source.html#l00079">79</a> of file <a class="el" href="physical_8hh_source.html">physical.hh</a>.</p>

<p>Referenced by <a class="el" href="physical_8cc_source.html#l00201">isMemAddr()</a>.</p>

</div>
</div>
<a class="anchor" id="a5593123b31f52c14675a125076fca73e"></a><!-- doxytag: member="PhysicalMemory::size" ref="a5593123b31f52c14675a125076fca73e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t <a class="el" href="classPhysicalMemory.html#a5593123b31f52c14675a125076fca73e">PhysicalMemory::size</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="physical_8hh_source.html#l00085">85</a> of file <a class="el" href="physical_8hh_source.html">physical.hh</a>.</p>

<p>Referenced by <a class="el" href="physical_8hh_source.html#l00151">totalSize()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>mem/<a class="el" href="physical_8hh_source.html">physical.hh</a></li>
<li>mem/<a class="el" href="physical_8cc_source.html">physical.cc</a></li>
</ul>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&nbsp;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1"><address style="align: right;"><small>
Generated on Sun Apr 7 2013 18:18:24 for gem5 by <a href="http://www.doxygen.org/index.html"> doxygen</a> 1.7.1</small></address>

</body>
</html>
